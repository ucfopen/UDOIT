import React, { useState, useEffect } from 'react'
import FixIssuesFilters from './FixIssuesFilters'
import FixIssuesList from './FixIssuesList'
import UfixitWidget from './UfixitWidget'
import FixIssuesContentPreview from './FixIssuesContentPreview'
import DailyProgress from './DailyProgress'
import LeftArrowIcon from './Icons/LeftArrowIcon'
import RightArrowIcon from './Icons/RightArrowIcon'
import { formNameFromRule } from '../Services/Ufixit'
import * as Html from '../Services/Html'
import Api from '../Services/Api'

import './FixIssuesPage.css'

/** The data for this component can be a bit confusing, so here's a breakdown:
  * - report: The main report object is generated by the scanner.
  * --- report.issues: All of the issues in a format that mirrors the database. Saving a loading is done with this.
  * --- report.files: All of the files in a format that mirrors the database. Saving a loading is done with this.
  * --- report.contentItems: All of the content items in the course. This is used to store the content for each issue.
  * 
  * After the data is brought in through the API, it is formatted in the formatIssueData and formatFileData functions
  * and stored in a list that can be filtered.
  * - unfilteredIssues: A list of all the issues in the course, formatted for the front end.
  * - filteredIssues: A list of the issues that match the current filters and search term.
  * - activeIssue: The issue that is currently being viewed and edited, including non-database attributes
  * --- activeIssue.issueData: The issue as it is stored in the database. Matches report.issues for the issue.
  * --- activeIssue.fileData: The file as it is stored in the database. Matches report.files for the file.
**/

export default function FixIssuesPage({
  t,
  settings,
  initialSeverity = '',
  initialSearchTerm = '',
  contentItemCache,
  addContentItemToCache,
  report,
  sections,
  processNewReport,
  addMessage,
  updateReportIssue,
  sessionIssues,
  updateSessionIssue,
  processServerError
})
{



  // Define the kinds of filters that will be available to the user
  const FILTER = {
    TYPE: {
      SEVERITY: 'SEVERITY',
      CONTENT_TYPE: 'CONTENT_TYPE',
      RESOLUTION: 'RESOLUTION',
      MODULE: 'MODULE',
      PUBLISHED: 'PUBLISHED',
    },
    ALL: 'ALL',
    ISSUE: 'ISSUE',
    POTENTIAL: 'POTENTIAL',
    SUGGESTION: 'SUGGESTION',
    PAGE: 'PAGE',
    ASSIGNMENT: 'ASSIGNMENT',
    ANNOUNCEMENT: 'ANNOUNCEMENT',
    DISCUSSION_TOPIC: 'DISCUSSION_TOPIC',
    DISCUSSION_FORUM: 'DISCUSSION_FORUM',
    FILE: 'FILE',
    QUIZ: 'QUIZ',
    SYLLABUS: 'SYLLABUS',
    MODULE: 'MODULE',
    FILE_OBJECT: 'FILE_OBJECT',
    ACTIVE: 'ACTIVE',
    FIXED: 'FIXED',
    RESOLVED: 'RESOLVED',
    FIXEDANDRESOLVED: 'FIXEDANDRESOLVED', // Doesn't appear in any dropdowns, but is used in the code
    PUBLISHED: 'PUBLISHED',
    UNPUBLISHED: 'UNPUBLISHED',
  }

  const defaultFilters = {
    [FILTER.TYPE.SEVERITY]: FILTER.ALL,
    [FILTER.TYPE.PUBLISHED]: FILTER.PUBLISHED,
    [FILTER.TYPE.CONTENT_TYPE]: FILTER.ALL,
    [FILTER.TYPE.RESOLUTION]: FILTER.ACTIVE,
    [FILTER.TYPE.MODULE]: FILTER.ALL,
  }

  const defaultNoFilters = {
    [FILTER.TYPE.SEVERITY]: FILTER.ALL,
    [FILTER.TYPE.PUBLISHED]: FILTER.ALL,
    [FILTER.TYPE.CONTENT_TYPE]: FILTER.ALL,
    [FILTER.TYPE.RESOLUTION]: FILTER.ALL,
    [FILTER.TYPE.MODULE]: FILTER.ALL,
  }

  const WIDGET_STATE = {
    LOADING: 0,
    FIXIT: 1,
    LEARN: 2,
    LIST: 3,
    NO_RESULTS: 4,
  }

  const FILE_TYPES = [
    'pdf',
    'doc',
    'ppt',
    'xls',
  ]

  const [activeIssue, setActiveIssue] = useState(null)
  const [activeContentItem, setActiveContentItem] = useState(null)
  const [contentItemsBeingScanned, setContentItemsBeingScanned] = useState([])
  const [isErrorFoundInContent, setIsErrorFoundInContent] = useState(false)
  const [editedElement, setEditedElement] = useState(null)
  const [searchTerm, setSearchTerm] = useState('')
  const [activeFilters, setActiveFilters] = useState(defaultFilters)
  const [unfilteredIssues, setUnfilteredIssues] = useState([])
  const [filteredIssues, setFilteredIssues] = useState([])
  const [groupedList, setGroupedList] = useState([])
  const [widgetState, setWidgetState] = useState(WIDGET_STATE.LOADING)
  const [viewInfo, setViewInfo] = useState(false)

  // The database stores and returns certain issue data, but it needs additional attributes in order to
  // be really responsive on the front end. This function adds those attributes and stores the database
  // information in the "issue" attribute.
  const formatIssueData = (issue) => {

    let issueSeverity = FILTER.ISSUE
    // PHPAlly returns a type of 'error' or 'suggestion'
    if(issue.type === 'suggestion' || issue.type === 'SUGGESTION') {
      issueSeverity = FILTER.SUGGESTION
    }
    else if(issue.type === 'potential' || issue.type === 'POTENTIAL' || issue.type === 'MANUAL') {
      issueSeverity = FILTER.POTENTIAL
    }
    
    let issueContentType = FILTER.ALL
    let issueSectionIds = []
    let published = true

    // PHPAlly returns a contentItemId that we can use to get the content type
    let tempContentItem = getContentById(issue.contentItemId)
    if(tempContentItem) {
      let tempContentType = tempContentItem.contentType

      const contentTypeMap = {
        'page': FILTER.PAGE,
        'assignment': FILTER.ASSIGNMENT,
        'announcement': FILTER.ANNOUNCEMENT,
        'discussion_topic': FILTER.DISCUSSION_TOPIC,
        'discussion_forum': FILTER.DISCUSSION_FORUM,
        'file': FILTER.FILE,
        'quiz': FILTER.QUIZ,
        'syllabus': FILTER.SYLLABUS,
        'module': FILTER.MODULE,
      }

      if(contentTypeMap[tempContentType]) {
        issueContentType = contentTypeMap[tempContentType]
      }

      // See if the issue's content is listed in one of the sections

// Canvas Content Item Data:
  // contentType: "page"
  // id: 61
  // lmsContentId: "4-dot-1-2-name-role-value-input-fields"
  // status: true
  // title: "4.1.2 Name, Role, Value - Input Fields"
  // updated: "2025-01-13T13:46:05+00:00"
  // url: "https://canvas.dev.cdl.ucf.edu/courses/383/pages/4-dot-1-2-name-role-value-input-fields"


// Canvas Section Item Data:
  // html_url: "https://canvas.dev.cdl.ucf.edu/courses/383/modules/items/3896"
  // id: 3896
  // indent: 0
  // module_id: 562
  // page_url: "4-dot-1-2-name-role-value-input-fields"
  // position: 1
  // published: true
  // quiz_lti: false
  // title: "4.1.2 Name, Role, Value - Input Fields"
  // type: "Page"
  // url: "https://canvas.dev.cdl.ucf.edu/api/v1/courses/383/pages/4-dot-1-2-name-role-value-input-fields"


      /* TODO: Find a more consistent way to filter this that works with less bespoke data.
        In Canvas, the modules and moduleItems have names and links, but do not have the
        contentItemId, which is necessary to match the issue to the content. The only current
        data that matches are the moduleItem's page_url are the contentItem's lmsContentId,
        which are both the same internal link URL. */
        
      if(sections && sections.length > 0) {
        sections.forEach((section) => {
          let tempSectionId = section.id
          section.items.forEach((item) => {
            if(item.page_url && item.page_url === tempContentItem.lmsContentId) {
              issueSectionIds.push(tempSectionId.toString())
            }
          })
        })
      }

      if(tempContentItem.published === false) {
        published = false
      }
    }

    let issueResolution = FILTER.ACTIVE
    // PHPAlly returns a status of 1 for fixed issues and 2 for resolved issues
    if(issue.status == 1) {
      issueResolution = FILTER.FIXED
    }
    else if(issue.status == 2) {
      issueResolution = FILTER.RESOLVED
    }
    else if(issue.status === 3) {
      issueResolution = FILTER.FIXEDANDRESOLVED
    }

    let currentState = settings.ISSUE_STATE.UNCHANGED
    if(sessionIssues && sessionIssues[issue.id]) {
      currentState = sessionIssues[issue.id]
    }

    let formName = formNameFromRule(issue.scanRuleId)
    let formLabel = t(`form.${formName}.title`)

    return {
      issueData: Object.assign({}, issue, { contentUrl: tempContentItem?.url || '' }),
      id: issue.id,
      severity: issueSeverity,
      status: issueResolution,
      published: published,
      sectionIds: issueSectionIds,
      keywords: createKeywords(issue, formLabel, tempContentItem),
      scanRuleId: issue.scanRuleId,
      formName: formName,
      formLabel: formLabel,
      contentId: tempContentItem.lmsContentId,
      contentType: issueContentType,
      contentTitle: tempContentItem.title,
      contentUrl: tempContentItem.url,
      currentState: currentState, 
    }
  }

  const formatFileData = (fileData) => {
    // All files should be considered "Potential Issues" since they need to be reviewed and are
    // not included in the PHPAlly or IBM Equal Access scan.

    let fileId = "file-" + fileData.id

    let issueResolution = FILTER.ACTIVE
    if(fileData.reviewed) {
      issueResolution = FILTER.RESOLVED
    }

    let formLabel = t(`form.file.title`)

    let fileTypeLabel = t(`label.mime.unknown`)
    
    // Guarantee that the keywords include the word "file" in each language
    let keywords = [ fileData.fileName.toLowerCase(), fileTypeLabel.toLowerCase(), formLabel.toLowerCase() ]
    
    // Keywords should include the file type ('MS Word', 'PDF', etc.)
    if(FILE_TYPES.includes(fileData.fileType)) {
      fileTypeLabel = t(`label.mime.${fileData.fileType}`)
      keywords.push[fileTypeLabel.toLowerCase()]
    }

    keywords = keywords.join(' ')

// Canvas File Item Data:
  // active: true
  // downloadUrl: "https://canvas.dev.cdl.ucf.edu/files/13041/download?download_frd=1&verifier=V4WBmWDBfN64x09tieoEqjfKWQWaK0HKXBI0CF54"
  // fileName: "1742314259_587__UCF-_Getting_Started_with_Serverless.pdf"
  // fileSize: "1923148"
  // fileType: "pdf"
  // hidden: false
  // id: 7
  // lmsFileId: "13041"
  // lmsUrl: "https://canvas.dev.cdl.ucf.edu/courses/383/files?preview=13041"
  // reviewed: null
  // status: true
  // updated: "2025-03-18T16:11:00+00:00"

// Canvas Section Item Data:
  // content_id: 13041
  // html_url: "https://canvas.dev.cdl.ucf.edu/courses/383/modules/items/4020"
  // id: 4020
  // indent: 0
  // module_id: 583
  // position: 1
  // published: true
  // quiz_lti: false
  // title: "UCF- Getting Started with Serverless.pdf"
  // type: "File"
  // url: "https://canvas.dev.cdl.ucf.edu/api/v1/courses/383/files/13041"

    let fileSectionIds = []

    if(sections && sections.length > 0) {
      sections.forEach((section) => {
        let tempSectionId = section.id
        section.items.forEach((item) => {
          if(item.content_id && item.content_id.toString() === fileData.lmsFileId.toString()) {
            fileSectionIds.push(tempSectionId.toString())
          }
        })
      })
    }

    let currentState = settings.ISSUE_STATE.UNCHANGED
    if(sessionIssues && sessionIssues[fileId]) {
      currentState = sessionIssues[fileId]
    }

    return {
      fileData: Object.assign({}, fileData),
      id: fileId,
      severity: FILTER.POTENTIAL,
      status: issueResolution,
      published: true,
      sectionIds: fileSectionIds,
      keywords: keywords,
      scanRuleId: 'verify_file_accessibility',
      formLabel: formLabel,
      contentId: fileData.lmsFileId,
      contentType: FILTER.FILE_OBJECT,
      contentTitle: fileData.fileName,
      contentUrl: fileData.lmsUrl,
      currentState: currentState,
    }
  }

  const addItemToBeingScanned = (contentItemId) => {
    let tempContentItems = contentItemsBeingScanned
    if(!tempContentItems.includes(contentItemId)) {
      tempContentItems.push(contentItemId)
      setContentItemsBeingScanned(tempContentItems)
    }
  }

  const removeItemFromBeingScanned = (contentItemId) => {
    let tempContentItems = contentItemsBeingScanned
    if(tempContentItems.includes(contentItemId)) {
      tempContentItems = tempContentItems.filter((item) => item !== contentItemId)
      setContentItemsBeingScanned(tempContentItems)
    }
  }

  const groupList = (tempFilteredContent) => {
    const tempGroupedList = []

    // Get all of the issues' "formLabel" values
    const formLabels = tempFilteredContent.map((issue) => issue.formLabel)
    const uniqueFormLabels = [...new Set(formLabels)]

    uniqueFormLabels.sort((a, b) => {
      return (a.toLowerCase() < b.toLowerCase()) ? -1 : 1
    })

    // Group the issues by "formLabel"
    uniqueFormLabels.forEach((formLabel) => {
      const issues = tempFilteredContent.filter((issue) => issue.formLabel === formLabel)
      tempGroupedList.push({ formLabel: formLabel, issues })
    })

    return tempGroupedList
  }

  // The initialSeverity prop is used when clicking a "Fix Issues" button from the main dashboard.
  useEffect(() => {
    let tempSeverity = initialSeverity || FILTER.ALL
    if(initialSearchTerm) {
      setSearchTerm(initialSearchTerm)
      setActiveFilters(Object.assign({}, defaultNoFilters))
    }
    else {
      setActiveFilters(Object.assign({}, defaultFilters, {[FILTER.TYPE.SEVERITY]: tempSeverity}))
    }
  }, [])

  // When the filters or search term changes, update the filtered issues list
  useEffect(() => {

    let tempFilteredContent = getFilteredContent(unfilteredIssues)
    setFilteredIssues(tempFilteredContent)
    setGroupedList(groupList(tempFilteredContent))

    setWidgetState(WIDGET_STATE.LIST)

  }, [activeFilters, searchTerm])

  // The report object is updated whenever a scan or rescan is completed. At this point, the list of issues
  // needs to be rebuilt and the activeIssue may need to be updated. For instance, if an issue is marked as
  // unreviewed then it will be deleted during the rescan and a new issue with a new id will take its place.
  useEffect(() => {
    let tempIssues = Object.assign({}, report.issues)
    let tempUnfilteredIssues = []

    for (const [key, value] of Object.entries(tempIssues)) {
      let tempIssue = formatIssueData(value)
      tempUnfilteredIssues.push(tempIssue)
    }

    let tempFiles = Object.assign({}, report.files)
    for (const [key, value] of Object.entries(tempFiles)) {
      let tempFile = formatFileData(value)
      tempUnfilteredIssues.push(tempFile)
    }

    tempUnfilteredIssues.sort((a, b) => {
      return (a.formLabel.toLowerCase() < b.formLabel.toLowerCase()) ? -1 : 1
    })

    // Every time the list changes, we need to reload the activeContentItem. This will come from the
    // cache (contentItemCache) or from the database, if not in the cache.
    setActiveContentItem(null)

    // The filtered list should ALWAYS include the current activeIssue, even if it no longer matches
    // the filters. For instance, if I'm only looking through "Unreviewed" issues, and I click on the
    // "Mark as Reviewed" button, that newly-reviewed issue should be available to stay on screen.
    let tempActiveIssue = null

    // If there is an activeIssue, we need to connect it to something in the new list of issues.
    if(activeIssue) {  
      // Quick check: is the old activeIssue still in the list?
      tempUnfilteredIssues.forEach((issue) => {
        if(issue.id === activeIssue.id) {
          tempActiveIssue = issue
        }
      })

      // If not, we need to do a more thorough check.
      if(tempActiveIssue === null) {
        if(activeIssue.contentType === FILTER.FILE_OBJECT) {
          tempUnfilteredIssues.forEach((issue) => {
            if(issue.contentId === activeIssue.contentId) {
              tempActiveIssue = issue
            }
          })
        }
        else {
          tempUnfilteredIssues.forEach((issue) => {
            if(issue.scanRuleId === activeIssue.scanRuleId &&
                issue.contentId === activeIssue.contentId &&
                issue.issueData.xpath === activeIssue.issueData.xpath) {
              updateActiveSessionIssue(issue.id, null, issue.issueData.contentItemId)
              tempActiveIssue = issue
            }
          })
        }
      }

      if(tempActiveIssue === null) {
        setWidgetState(WIDGET_STATE.LIST)
      }
    }

    setUnfilteredIssues(tempUnfilteredIssues)
    let tempFilteredContent = getFilteredContent(tempUnfilteredIssues, tempActiveIssue?.id || null)

    setFilteredIssues(tempFilteredContent)
    setGroupedList(groupList(tempFilteredContent))
    setActiveIssue(tempActiveIssue)

  }, [report])


  // When a new activeIssue is set, get the content for that issue
  useEffect(() => {
    if(activeIssue === null) {
      setActiveContentItem(null)
      setWidgetState(WIDGET_STATE.LIST)
      return
    }
  
    setWidgetState(WIDGET_STATE.FIXIT)

    if(activeIssue.contentType === FILTER.FILE_OBJECT) {
      setActiveContentItem(null)
      setIsErrorFoundInContent(true)
      return
    }

    // If we've already downloaded the content for this issue, use that
    const contentItemId = activeIssue.issueData.contentItemId
    if(contentItemCache[contentItemId]) {
      setActiveContentItem(contentItemCache[contentItemId])
      return
    }

    // Otherwise, clear the old content and download the content for this issue
    setActiveContentItem(null)
    loadContentItemByIssue(activeIssue)

  }, [activeIssue])

  useEffect(() => {
    let tempContentItem = null
    if(activeIssue?.issueData?.contentItemId) {
      tempContentItem = contentItemCache[activeIssue.issueData.contentItemId] || null
    }
    setActiveContentItem(tempContentItem)
  }, [contentItemCache])

  const getFilteredContent = (allIssues, includedIssueId = null) => {
    let filteredList = []
    const tempFilters = Object.assign({}, activeFilters)

    // PHPAlly Issues have a 'type' of 'error' or 'suggestion'
    // // Check for easy issues filter
    // if (tempFilters.easyIssues && tempFilters.issueTitles.length == 0) {
    //   tempFilters.issueTitles = easyRules
    // }
    // Loop through the issues

    for (const issue of allIssues) {

      // When we have just saved or resolved an issue, we want to keep that one in the list
      // even if it doesn't match the filters. This is used to show the user that their changes
      // were successful.
      if(includedIssueId && issue.id === includedIssueId) {
        filteredList.push(issue)
        continue
      }

      // Do not include this issue if it doesn't match the severity filter
      if (tempFilters[FILTER.TYPE.SEVERITY] !== FILTER.ALL && tempFilters[FILTER.TYPE.SEVERITY] !== issue.severity) {
        continue
      }

      // Do not include this issue if it doesn't match the content type filter
      let tempContentType = issue.contentType
      let tempStatus = issue.status === FILTER.FIXEDANDRESOLVED ? FILTER.FIXED : issue.status
      if (tempContentType === FILTER.FILE_OBJECT) {
        // When the user selects "Files", show both "File" issues as well as external File objects
        tempContentType = FILTER.FILE
      }
      if (tempFilters[FILTER.TYPE.CONTENT_TYPE] !== FILTER.ALL && tempFilters[FILTER.TYPE.CONTENT_TYPE] !== tempContentType) {
        continue
      }

      // Do not include this issue if it doesn't match the status filter
      if (tempFilters[FILTER.TYPE.RESOLUTION] !== FILTER.ALL && tempFilters[FILTER.TYPE.RESOLUTION] !== tempStatus) {
        continue
      }

      // Do not include this issue if it doesn't match the module filter
      if (tempFilters[FILTER.TYPE.MODULE] !== FILTER.ALL && !issue.sectionIds.includes(tempFilters[FILTER.TYPE.MODULE].toString())) {
        continue
      }

      // Do not include this issue if it doesn't match the published filter
      if (tempFilters[FILTER.TYPE.PUBLISHED] !== FILTER.ALL && (tempFilters[FILTER.TYPE.PUBLISHED] === FILTER.PUBLISHED) !== issue.published) {
        continue
      }

      // Do not include this issue if it doesn't contain the search term/s
      if (searchTerm !== '') {
        const searchTerms = searchTerm.toLowerCase().split(' ')
        let containsAllTerms = true
        if (Array.isArray(searchTerms)) {
          for (let term of searchTerms) {
            if (!issue.keywords.includes(term)) {
              containsAllTerms = false
            }
          }
        }
        if (!containsAllTerms) {
          continue
        }
      }

      // Check to see if the user ONLY wants to see issues from published content
      if(settings?.user?.roles?.view_only_published && issue.issueData) {
        let tempContentItem = getContentById(issue.issueData.contentItemId)
        if(tempContentItem && tempContentItem.published === false) {
          continue
        }
      }

      // If the issue passes all filters, add it to the list!
      filteredList.push(issue)
    }

    filteredList.sort((a, b) => {
      return (a.formLabel.toLowerCase() < b.formLabel.toLowerCase()) ? -1 : 1
    })

    return filteredList
  }

  const loadContentItemByIssue = (issue) => {
    let contentItemId = issue?.issueData?.contentItemId || null
    if(contentItemId) {
      addItemToBeingScanned(contentItemId)
      let api = new Api(settings)
      api.getIssueContent(issue.id)
      .then((response) => {
        return response.json()
      }).then((data) => {
        if(data?.data?.contentItem) {
          const newContentItem = data.data.contentItem
          addContentItemToCache(newContentItem)
        }
        removeItemFromBeingScanned(contentItemId)
      })
    }
  }


  // All local information must be updated to match the new issue state:
  // - activeIssue
  // - unfilteredIssues
  // - filteredIssues
  // This does NOT change the report object, which updates when the issue's data changes.
  const updateActiveSessionIssue = (issueId, state = null, contentItemId = null) => {
    
    if(state === null) {
      state = settings.ISSUE_STATE.UNCHANGED
    }
    // This updates the counter for the daily progress
    updateSessionIssue(issueId, state, contentItemId)

    // Only update the whole list if the issue is saved, resolved, or marked as unresolved.
    if(state === settings.ISSUE_STATE.SAVED
      || state === settings.ISSUE_STATE.RESOLVED
      || state === settings.ISSUE_STATE.UNCHANGED) {

        let tempUnfilteredIssues = unfilteredIssues.map((issue) => {
          if(issue.id === issueId) {
            let tempIssue = Object.assign({}, issue)
            tempIssue.currentState = state
            return tempIssue
          }
          return issue
        })
        setUnfilteredIssues(tempUnfilteredIssues)
        setFilteredIssues(getFilteredContent(tempUnfilteredIssues, activeIssue?.id || null))
    }

    // This updates the active issue to the current state, which allows the proper UI to show
    // (like "Processing..." which disables the buttons).
    if(activeIssue) {
      let tempIssue = Object.assign({}, activeIssue)
      if(tempIssue.id === issueId) {
        tempIssue.currentState = state
        setActiveIssue(tempIssue)
      }
    }
  }

  const updateFile = (tempFile, oldFile) => {
    const tempReport = Object.assign({}, report)
    if(activeIssue?.fileData?.id === oldFile.id){ // Check if we are still on the same issue 
      const formattedFile = formatFileData(tempFile);
      setActiveIssue(formattedFile); // Make it the new issue
    }
    tempReport.files[tempFile.id] = tempFile;
    delete tempReport.files[oldFile.id]; // Delete the old file

    // Occasionally, the report will send back a list of files in an object instead of an array.
    // It would be nice to use tempReport.files.map, but that doesn't work with objects.
    // for (const [key, value] of Object.entries(tempReport.files)) {
    //   if (key.toString() === tempFile.id.toString()) {
    //     if(activeIssue?.fileData?.id === tempFile.id) {
    //       const formattedFile = formatFileData(tempFile)
    //       setActiveIssue(formattedFile)
    //     }
    //     tempReport.files[key] = tempFile
    //   }
    // }
    processNewReport(tempReport)
  }

  const getNewFullPageHtml = (content, issue) => {
    if(!content?.body || !issue) {
      return
    }

    // Create the full HTML string for the new version of the content item.
    const parser = new DOMParser()
    const tempDoc = parser.parseFromString(content.body, 'text/html')

    let errorElement = Html.findElementWithIssue(tempDoc, issue)
      
    if(!errorElement) {
      console.warn("Could not find error element when attempting to save...")
      return
    }
    const newElement = Html.toElement(issue?.newHtml)
    
    // Replace or remove the error element
    if(newElement) {
      errorElement.replaceWith(newElement)  
    } else {
      errorElement.remove()
    }

    return tempDoc.body.innerHTML
  }

  const handleIssueSave = (issue) => {

    if(!activeContentItem || !issue) {
      return
    }

    updateActiveSessionIssue(issue.id, settings.ISSUE_STATE.SAVING)
    addItemToBeingScanned(issue.contentItemId)

    if(!activeContentItem?.body) {
      return
    }

    let fullPageHtml = getNewFullPageHtml(activeContentItem, issue)
    let fullPageDoc = new DOMParser().parseFromString(fullPageHtml, 'text/html')
    let newElement = Html.findElementWithError(fullPageDoc, issue?.newHtml)
    let newXpath = Html.findXpathFromElement(newElement)
    if(newXpath) {
      issue.xpath = newXpath
    }
    else {
      issue.xpath = ""
    }
    activeContentItem.body = fullPageHtml

    // Save the updated issue using the LMS API
    let api = new Api(settings)
    try {
      api.saveIssue(issue, fullPageHtml)
      .then((responseStr) => {
        // Check for HTTP errors before parsing JSON
          if (!responseStr.ok) {
            processServerError(responseStr)
            updateActiveSessionIssue(issue.id, settings.ISSUE_STATE.ERROR)
            removeItemFromBeingScanned(issue.contentItemId)
            return null
          }
          return responseStr.json()
      })
      .then((response) => {

        // If the save falied, show the relevant error message
        if (response.data.failed) {
          updateActiveSessionIssue(issue.id, settings.ISSUE_STATE.ERROR)
          removeItemFromBeingScanned(issue.contentItemId)
          response.messages.forEach((msg) => addMessage(msg))
            
          if (Array.isArray(response.data.issues)) {
            response.data.issues.forEach((issue) => {
              addMessage({
                severity: 'error',
                message: t(`form.error.${issue.ruleId}`)
              })
            })
          }

          if (Array.isArray(response.data.errors)) {
            response.data.errors.forEach((error) => {
              addMessage({
                severity: 'error',
                message: error
              })
            })
          }
        }
        else {
          
          // If the save was successful, show the success message
          response.messages.forEach((msg) => addMessage(msg))
          
          if (response.data.issue) {
            // Update the report object by rescanning the content
            const newIssue = Object.assign({}, issue, response.data.issue)
            const formattedData = formatIssueData(newIssue)
            setActiveIssue(formattedData)
            updateActiveSessionIssue(newIssue.id, settings.ISSUE_STATE.SAVED)

            api.scanContent(newIssue.contentItemId)
              .then((responseStr) => responseStr.json())
              .then((res) => { 
                const tempReport = Object.assign({}, res?.data)
                processNewReport(tempReport)
                removeItemFromBeingScanned(newIssue.contentItemId)
              })
          }
          else {
            setActiveIssue(formatIssueData(issue))
            updateActiveSessionIssue(issue.id, settings.ISSUE_STATE.SAVED)
            removeItemFromBeingScanned(issue.contentItemId)
          }
        }
      })
    } catch (error) {
      console.error(error)
      updateActiveSessionIssue(issue.id, settings.ISSUE_STATE.ERROR)
    }
  }

  /**
   * handleFileUpload is called when a new file has already been selected by the user
   * and is ready to be uploaded to the server and verified.
   */
  const handleFileUpload = (newFileData, references) => {

    const tempFile = Object.assign({}, activeIssue.fileData) // Copy over the current file

    updateActiveSessionIssue("file-" + tempFile.id, settings.ISSUE_STATE.SAVING)
    console.log("References from fixPageIssues: " + references);

    try {
      let api = new Api(settings) // API Call 
      api.postFile(tempFile, newFileData, references) 
        .then((responsStr) => responsStr.json())
        .then((response) => {
          // let updatedFileData = Object.assign({}, tempFile) // New copy of the file to add updated fields
          // // Iterate over every key value pair from response and update them in response, very short O(1) as we are going over the same number of key value pairs everytime
          
          // for(const [key, value] of Object.entries(response.data.data.content)){
          //   if(key.toString() === 'id'){
          //     updatedFileData.lmsFileId = value;
          //     updatedFileData.lmsUrl = updatedFileData.lmsUrl.replace(/preview=\d+/, `preview=${value}`)
          //   }
          //   if(key.toString() === 'filename'){
          //     updatedFileData.fileName = value;
          //   }
          //   if(key.toString() === 'size'){
          //     updatedFileData.fileSize = value;
          //   }
          //   if(key.toString() === 'url'){
          //     updatedFileData.downloadUrl = value;
          //   }
          // }
          const newFile = response.data; // Get the new file data from the response
          // Set messages 
          response.messages.forEach((msg) => addMessage(msg))
          // Update the local report and activeIssue
          updateFile(newFile, tempFile)
          updateActiveSessionIssue("file-" + newFile.id, settings.ISSUE_STATE.RESOLVED)
          
        })
    } catch (error) {
      console.error(error)
      updateActiveSessionIssue("file-" + tempFile.id, settings.ISSUE_STATE.ERROR)
    }
  }

  const handleIssueResolve = (issue) => {
    updateActiveSessionIssue(issue.id, settings.ISSUE_STATE.RESOLVING)
    addItemToBeingScanned(issue.contentItemId)
    
    const specificClassName = `udoit-ignore-${issue.scanRuleId.replaceAll("_", "-")}`
    let tempIssue = Object.assign({}, issue)
    if (tempIssue.status === 2) {
      tempIssue.status = 0
      tempIssue.newHtml = Html.toString(Html.removeClass(tempIssue.sourceHtml, specificClassName))
    }
    else if (tempIssue.status === 1) {
      tempIssue.status = 3
      tempIssue.newHtml = Html.toString(Html.addClass(tempIssue.newHtml, specificClassName))
    }
    else if (tempIssue.status === 3) {
      tempIssue.status = 1
      tempIssue.newHtml = Html.toString(Html.removeClass(tempIssue.newHtml, specificClassName))
    }
    else {
      tempIssue.status = 2
      tempIssue.newHtml = Html.toString(Html.addClass(tempIssue.sourceHtml, specificClassName))
    }

    let fullPageHtml = getNewFullPageHtml(activeContentItem, tempIssue)

    // Save the updated issue using the LMS API
    let api = new Api(settings)
    try {
      api.resolveIssue(tempIssue, fullPageHtml)
        .then((responseStr) => {
          // Check for HTTP errors before parsing JSON
          if (!responseStr.ok) {
            processServerError(responseStr)
            removeItemFromBeingScanned(tempIssue.contentItemId)
            updateActiveSessionIssue(issue.id, settings.ISSUE_STATE.ERROR)
            return null
          }
          return responseStr.json()
        })
        .then((response) => {
          if(!response) {
            return
          }

          response.messages.forEach((msg) => addMessage(msg))
        
          if (response.data.issue) {
            const newIssue = { ...tempIssue, ...response.data.issue }

            if(activeIssue.id === tempIssue.id) {
              setActiveIssue(formatIssueData(newIssue))
            }

            // Get updated report
            api.scanContent(newIssue.contentItemId)
              .then((responseStr) => responseStr.json())
              .then((res) => {
                const tempReport = Object.assign({}, res?.data)
                processNewReport(tempReport)
                
                if(!tempIssue.status) {
                  updateActiveSessionIssue(tempIssue.id, null)
                }
                else if(tempIssue.status === 1) {
                  updateActiveSessionIssue(tempIssue.id, settings.ISSUE_STATE.SAVED)
                }
                else if(tempIssue.status === 2) {
                  updateActiveSessionIssue(tempIssue.id, settings.ISSUE_STATE.RESOLVED)
                }
                setActiveContentItem(null)
                removeItemFromBeingScanned(newIssue.contentItemId)
            })
          }
          else {
            updateActiveSessionIssue(tempIssue.id, settings.ISSUE_STATE.RESOLVED)
            setActiveContentItem(null)
            setActiveIssue(formatIssueData(tempIssue))
          }
        })
    } catch (error) {
      console.error(error)
      updateActiveSessionIssue(issue.id, settings.ISSUE_STATE.ERROR)
    }
  }

  const handleFileResolve = (fileData) => {
    updateActiveSessionIssue("file-" + fileData.id, settings.ISSUE_STATE.RESOLVING)
    
    let tempFile = Object.assign({}, fileData)
    tempFile.reviewed = !(tempFile.reviewed) 

    try {
      let api = new Api(settings)
      api.reviewFile(tempFile)
        .then((responseStr) => responseStr.json())
        .then((response) => {
          const reviewed = (response?.data?.file && ('reviewed' in response.data.file)) ? response.data.file.reviewed : false
          const newFileData = { ...tempFile }
          newFileData.reviewed = reviewed

          // Set messages
          response.messages.forEach((msg) => addMessage(msg))

          // Update the local report and activeIssue
          if(reviewed) {
            updateActiveSessionIssue("file-" + fileData.id, settings.ISSUE_STATE.RESOLVED)
          }
          else {
            updateActiveSessionIssue("file-" + fileData.id, settings.ISSUE_STATE.UNCHANGED)
          }
          updateFile(newFileData)
        })
    } catch (error) {
      console.warn(error)
      updateActiveSessionIssue("file-" + fileData.id, settings.ISSUE_STATE.ERROR)
    }
  }

  const updateActiveFilters = (filter, value) => {
    setActiveFilters(Object.assign({}, activeFilters, {[filter]: value}))
  }

  const nextIssue = (previous = false) => {
    if (!activeIssue || filteredIssues.length < 2) { return }
    let activeIndex = filteredIssues.findIndex((issue) => issue.id === activeIssue.id)

    if(activeIndex === -1) { return }

    // If we've reached the first or last issue, loop around
    let newIndex = activeIndex + (previous ? -1 : 1)
    if (newIndex < 0) {
      newIndex = filteredIssues.length - 1
    }
    else if (newIndex >= filteredIssues.length) {
      newIndex = 0
    }
    setActiveIssue({...filteredIssues[newIndex]})
    setViewInfo(false)
  }

  const toggleListView = () => {
    if (widgetState === WIDGET_STATE.LIST) {
      if(activeIssue) {
        setWidgetState(WIDGET_STATE.FIXIT)
      }
      else {
        setWidgetState(WIDGET_STATE.NO_RESULTS)
      }
    }
    else {
      setWidgetState(WIDGET_STATE.LIST)
      setViewInfo(false)
      setActiveIssue(null)
      setActiveContentItem(null)
    }
  }

  const getContentById = (contentId) => {
    if(!report.contentItems[contentId]) {
      return null
    }
    return report.contentItems[contentId]
  }

  const createKeywords = (issue, formName, contentItem) => {
    let keywords = []

    if(formName !== '') {
      keywords.push(formName.toLowerCase())
    }
    if(issue?.scanRuleId) {
      keywords.push(issue.scanRuleId.toLowerCase())
    }
    if(contentItem?.contentType) {
      keywords.push(t(`label.${contentItem.contentType}`).toLowerCase())
    }
    if(contentItem?.title) {
      keywords.push(contentItem.title.toLowerCase())
    }

    return keywords.join(' ')
  }


  return (
    <>
      { widgetState === WIDGET_STATE.LOADING ? (
        <></>
      ) : widgetState === WIDGET_STATE.LIST ? (
        <>
          <FixIssuesFilters
            t={t}
            settings={settings.FILTER ? settings : Object.assign({}, settings, { FILTER })}
            sections={sections}
            activeFilters={activeFilters}
            updateActiveFilters={updateActiveFilters}
            searchTerm={searchTerm}
            handleSearchTerm={setSearchTerm}
          />
          <FixIssuesList
            t={t}
            settings={settings.FILTER ? settings : Object.assign({}, settings, { FILTER })}
            groupedList={groupedList}
            setActiveIssue={setActiveIssue}
          />
        </>
      ) : (
        <div className="ufixit-page-divider flex-row h-100">
          <section className='ufixit-widget-container'>
            <button onClick={toggleListView} className="btn btn-link btn-icon-left btn-small mb-2">
              <LeftArrowIcon className="icon-sm link-color" />{t('fix.button.list')}
            </button>
            { activeIssue ? (  
                <UfixitWidget
                  t={t}
                  settings={settings.FILTER ? settings : Object.assign({}, settings, { FILTER })}
                  viewInfo={viewInfo}
                  setViewInfo={setViewInfo}
                  severity={activeIssue.severity}
                  addMessage={addMessage}
                  activeIssue={activeIssue}
                  setActiveIssue={setActiveIssue}
                  setEditedElement={setEditedElement}
                  formatIssueData={formatIssueData}
                  isContentLoading={contentItemsBeingScanned.includes(activeIssue?.issueData?.contentItemId)}
                  isErrorFoundInContent={isErrorFoundInContent}
                  handleIssueResolve={handleIssueResolve}
                  handleIssueSave={handleIssueSave}
                  handleFileResolve={handleFileResolve}
                  handleFileUpload={handleFileUpload}
                  toggleListView={toggleListView}
                  listLength={filteredIssues.length}
                  nextIssue={nextIssue}
                />
            ) : ''}
          </section>
          <section className="ufixit-content-container">
            {filteredIssues.length > 0 && (
              <FixIssuesContentPreview
                t={t}
                settings={settings.FILTER ? settings : Object.assign({}, settings, { FILTER })}
                activeIssue={activeIssue}
                activeContentItem={activeContentItem}
                editedElement={editedElement}
                sessionIssues={sessionIssues}
                isErrorFoundInContent={isErrorFoundInContent}
                setIsErrorFoundInContent={setIsErrorFoundInContent}
                contentItemsBeingScanned={contentItemsBeingScanned}
              />
            )}
            <div className="flex-row justify-content-end gap-2 mt-3">
              <button
                className={`btn btn-small btn-link btn-icon-left ${filteredIssues.length < 2 ? 'disabled' : ''}`}
                onClick={() => nextIssue(true)}
                tabIndex="0">
                <LeftArrowIcon className={`icon-sm ` + (filteredIssues.length < 2 ? 'gray' : 'link-color')} />
                <div className="flex-column justify-content-center">{t('fix.button.previous')}</div>
              </button>

              <button
                className={`btn btn-small btn-link btn-icon-right ${filteredIssues.length < 2 ? 'disabled' : ''}`}
                onClick={() => nextIssue()}
                tabIndex="0">
                <div className="flex-column justify-content-center">{t('fix.button.next')}</div>
                <RightArrowIcon className={`icon-sm ` + (filteredIssues.length < 2 ? 'gray' : 'link-color')} />
              </button>
            </div>
          </section>
        </div>
      )}
    </>
  )
}