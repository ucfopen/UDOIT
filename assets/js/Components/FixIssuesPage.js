import React, { useState, useEffect } from 'react'
import FixIssuesFilters from './Widgets/FixIssuesFilters'
import FixIssuesList from './Widgets/FixIssuesList'
import LearnMore from './Widgets/LearnMore'
import UfixitWidget from './Widgets/UfixitWidget'
import FixIssuesContentPreview from './Widgets/FixIssuesContentPreview'
import LeftArrowIcon from './Icons/LeftArrowIcon'
import RightArrowIcon from './Icons/RightArrowIcon'
import CloseIcon from './Icons/CloseIcon'
import { formNameFromRule } from '../Services/Ufixit'
import * as Html from '../Services/Html'
import Api from '../Services/Api'

import './FixIssuesPage.css'

/** The data for this component can be a bit confusing, so here's a breakdown:
  * - report: The main report object is generated by the scanner.
  * --- report.issues: All of the issues in a format that mirrors the database. Saving a loading is done with this.
  * --- report.files: All of the files in a format that mirrors the database. Saving a loading is done with this.
  * --- report.contentItems: All of the content items in the course. This is used to store the content for each issue.
  * 
  * After the data is brought in through the API, it is formatted in the formatIssueData and formatFileData functions
  * and stored in a list that can be filtered.
  * - unfilteredIssues: A list of all the issues in the course, formatted for the front end.
  * - filteredIssues: A list of the issues that match the current filters and search term.
  * - activeIssue: The issue that is currently being viewed and edited, including non-database attributes
  * --- activeIssue.issueData: The issue as it is stored in the database. Matches report.issues for the issue.
  * --- activeIssue.fileData: The file as it is stored in the database. Matches report.files for the file.
**/

export default function FixIssuesPage({
  t,
  settings,
  initialSeverity = '',
  initialSearchTerm = '',
  contentItemCache,
  addContentItemToCache,
  report,
  sections,
  processNewReport,
  addMessage,
  sessionIssues,
  updateSessionIssue,
  processServerError
})
{

  // Define the kinds of filters that will be available to the user
  const FILTER = settings.ISSUE_FILTER

  const defaultFilters = {
    [FILTER.TYPE.SEVERITY]: FILTER.ALL,
    [FILTER.TYPE.PUBLISHED]: FILTER.PUBLISHED,
    [FILTER.TYPE.CONTENT_TYPE]: FILTER.ALL,
    [FILTER.TYPE.RESOLUTION]: FILTER.ACTIVE,
    [FILTER.TYPE.MODULE]: FILTER.ALL,
  }

  const defaultNoFilters = {
    [FILTER.TYPE.SEVERITY]: FILTER.ALL,
    [FILTER.TYPE.PUBLISHED]: FILTER.ALL,
    [FILTER.TYPE.CONTENT_TYPE]: FILTER.ALL,
    [FILTER.TYPE.RESOLUTION]: FILTER.ALL,
    [FILTER.TYPE.MODULE]: FILTER.ALL,
  }

  const WIDGET_STATE = settings.WIDGET_STATE

  const dialogId = "issue-dialog"

  const [activeIssue, setActiveIssue] = useState(null)
  const [tempActiveIssue, setTempActiveIssue] = useState(null)
  const [activeContentItem, setActiveContentItem] = useState(null)
  const [contentItemsBeingScanned, setContentItemsBeingScanned] = useState([])
  const [showLearnMore, setShowLearnMore] = useState(false)
  const [markAsReviewed, setMarkAsReviewed] = useState(false)
  const [formInvalid, setFormInvalid] = useState(true)
  const [isErrorFoundInContent, setIsErrorFoundInContent] = useState(false)
  const [searchTerm, setSearchTerm] = useState('')
  const [activeFilters, setActiveFilters] = useState(defaultFilters)
  const [unfilteredIssues, setUnfilteredIssues] = useState([])
  const [filteredIssues, setFilteredIssues] = useState([])
  const [groupedList, setGroupedList] = useState([])
  const [widgetState, setWidgetState] = useState(WIDGET_STATE.LOADING)
  const [liveUpdateToggle, setLiveUpdateToggle] = useState(true)

  const getSectionTitles = () => {
    let sectionTitles = {}
    report.contentSections.forEach((section) => {
      sectionTitles[section.id] = section.title
    })
    return sectionTitles
  }

  const sectionTitles = getSectionTitles()

  // The database stores and returns certain issue data, but it needs additional attributes in order to
  // be really responsive on the front end. This function adds those attributes and stores the database
  // information in the "issue" attribute.
  const formatIssueData = (issue) => {

    let issueSeverity = FILTER.ISSUE
    // PHPAlly returns a type of 'error' or 'suggestion'
    if(issue.type === 'suggestion' || issue.type === 'SUGGESTION') {
      issueSeverity = FILTER.SUGGESTION
    }
    else if(issue.type === 'potential' || issue.type === 'POTENTIAL' || issue.type === 'MANUAL') {
      issueSeverity = FILTER.POTENTIAL
    }
    
    let issueContentType = FILTER.ALL
    let issueSectionIds = []
    let issueSectionNames = []
    let published = true

    // PHPAlly returns a contentItemId that we can use to get the content type
    let tempContentItem = getContentById(issue.contentItemId)
    if(tempContentItem) {
      let tempContentType = tempContentItem.contentType

      const contentTypeMap = {
        'page': FILTER.PAGE,
        'assignment': FILTER.ASSIGNMENT,
        'announcement': FILTER.ANNOUNCEMENT,
        'discussion_topic': FILTER.DISCUSSION_TOPIC,
        'discussion_forum': FILTER.DISCUSSION_FORUM,
        'file': FILTER.FILE,
        'quiz': FILTER.QUIZ,
        'syllabus': FILTER.SYLLABUS,
        'module': FILTER.MODULE,
      }

      if(contentTypeMap[tempContentType]) {
        issueContentType = contentTypeMap[tempContentType]
      }

      issueSectionIds = tempContentItem.sections || []
      issueSectionIds.forEach((sectionId) => {
        if(sectionTitles[sectionId]) {
          issueSectionNames.push(sectionTitles[sectionId])
        }
      })

      if(tempContentItem.published === false) {
        published = false
      }
    }

    let issueResolution = FILTER.ACTIVE
    // PHPAlly returns a status of 1 for fixed issues and 2 for resolved issues
    if(issue.status == 1) {
      issueResolution = FILTER.FIXED
    }
    else if(issue.status == 2) {
      issueResolution = FILTER.RESOLVED
    }
    else if(issue.status === 3) {
      issueResolution = FILTER.FIXEDANDRESOLVED
    }

    let currentState = settings.ISSUE_STATE.UNCHANGED
    if(sessionIssues && sessionIssues[issue.id]) {
      currentState = sessionIssues[issue.id]
    }

    let formName = formNameFromRule(issue.scanRuleId)
    let formLabel = t(`form.${formName}.title`)

    return {
      issueData: Object.assign({}, issue, { contentUrl: tempContentItem?.url || '' }),
      id: issue.id,
      severity: issueSeverity,
      status: issueResolution,
      published: published,
      sectionIds: issueSectionIds,
      sectionNames: issueSectionNames,
      keywords: createKeywords(issue, formLabel, tempContentItem),
      scanRuleId: issue.scanRuleId,
      formName: formName,
      formLabel: formLabel,
      contentId: tempContentItem.lmsContentId,
      contentType: issueContentType,
      contentTitle: tempContentItem.title,
      contentUrl: tempContentItem.url,
      currentState: currentState, 
    }
  }

  const addItemToBeingScanned = (contentItemId) => {
    let tempContentItems = contentItemsBeingScanned
    if(!tempContentItems.includes(contentItemId)) {
      tempContentItems.push(contentItemId)
      setContentItemsBeingScanned(tempContentItems)
    }
  }

  const removeItemFromBeingScanned = (contentItemId) => {
    let tempContentItems = contentItemsBeingScanned
    if(tempContentItems.includes(contentItemId)) {
      tempContentItems = tempContentItems.filter((item) => item !== contentItemId)
      setContentItemsBeingScanned(tempContentItems)
    }
  }

  const groupList = (tempFilteredContent) => {
    const tempGroupedList = []

    // Get all of the issues' "formLabel" values
    const formLabels = tempFilteredContent.map((issue) => issue.formLabel)
    const uniqueFormLabels = [...new Set(formLabels)]

    uniqueFormLabels.sort((a, b) => {
      return (a.toLowerCase() < b.toLowerCase()) ? -1 : 1
    })

    // Group the issues by "formLabel"
    uniqueFormLabels.forEach((formLabel) => {
      const issues = tempFilteredContent.filter((issue) => issue.formLabel === formLabel)
      tempGroupedList.push({ formLabel: formLabel, issues })
    })

    let lastLabel = t('form.review_only.title')
    tempGroupedList.sort((a, b) => {
      return (a.issues.length > b.issues.length && a.formLabel !== lastLabel) ? -1 : 1
    })

    return tempGroupedList
  }

  // The initialSeverity prop is used when clicking a "Fix Issues" button from the main dashboard.
  useEffect(() => {
    let tempSeverity = initialSeverity || FILTER.ALL
    if(initialSearchTerm) {
      setSearchTerm(initialSearchTerm)
      setActiveFilters(Object.assign({}, defaultNoFilters))
    }
    else {
      setActiveFilters(Object.assign({}, defaultFilters, {[FILTER.TYPE.SEVERITY]: tempSeverity}))
    }
  }, [])

  // When the filters or search term changes, update the filtered issues list
  useEffect(() => {

    let tempFilteredContent = getFilteredContent(unfilteredIssues)
    setFilteredIssues(tempFilteredContent)
    setGroupedList(groupList(tempFilteredContent))

    setWidgetState(WIDGET_STATE.LIST)

  }, [activeFilters, searchTerm])

  // The report object is updated whenever a scan or rescan is completed. At this point, the list of issues
  // needs to be rebuilt and the activeIssue may need to be updated. For instance, if an issue is marked as
  // unreviewed then it will be deleted during the rescan and a new issue with a new id will take its place.
  useEffect(() => {
    let tempIssues = Object.assign({}, report.issues)
    let tempUnfilteredIssues = []

    for (const [key, value] of Object.entries(tempIssues)) {
      let tempIssue = formatIssueData(value)
      tempUnfilteredIssues.push(tempIssue)
    }

    // let tempFiles = Object.assign({}, report.files)
    // for (const [key, value] of Object.entries(tempFiles)) {
    //   let tempFile = formatFileData(value)
    //   tempUnfilteredIssues.push(tempFile)
    // }

    tempUnfilteredIssues.sort((a, b) => {
      return (a.formLabel.toLowerCase() < b.formLabel.toLowerCase()) ? -1 : 1
    })

    // Every time the list changes, we need to reload the activeContentItem. This will come from the
    // cache (contentItemCache) or from the database, if not in the cache.
    setActiveContentItem(null)

    // The filtered list should ALWAYS include the current activeIssue, even if it no longer matches
    // the filters. For instance, if I'm only looking through "Unreviewed" issues, and I click on the
    // "Mark as Reviewed" button, that newly-reviewed issue should be available to stay on screen.
    let holdoverActiveIssue = null

    // If there is an activeIssue, we need to connect it to something in the new list of issues.
    if(activeIssue) {  
      // Quick check: is the old activeIssue still in the list?
      tempUnfilteredIssues.forEach((issue) => {
        if(issue.id === activeIssue.id) {
          holdoverActiveIssue = issue
        }
      })

      // If not, we need to do a more thorough check.
      if(holdoverActiveIssue === null) {
        if(activeIssue.contentType === FILTER.FILE_OBJECT) {
          tempUnfilteredIssues.forEach((issue) => {
            if(issue.contentId === activeIssue.contentId) {
              holdoverActiveIssue = issue
            }
          })
        }
        else {
          tempUnfilteredIssues.forEach((issue) => {
            if(issue.scanRuleId === activeIssue.scanRuleId &&
                issue.contentId === activeIssue.contentId &&
                issue.issueData.xpath === activeIssue.issueData.xpath) {
              updateActiveSessionIssue(issue.id, null, issue.issueData.contentItemId)
              holdoverActiveIssue = issue
            }
          })
        }
      }

      if(holdoverActiveIssue === null) {
        setWidgetState(WIDGET_STATE.LIST)
      }
    }

    setUnfilteredIssues(tempUnfilteredIssues)
    let tempFilteredContent = getFilteredContent(tempUnfilteredIssues, holdoverActiveIssue?.id || null)

    setFilteredIssues(tempFilteredContent)
    setGroupedList(groupList(tempFilteredContent))
    setActiveIssue(holdoverActiveIssue)
  }, [report])


  // When a new activeIssue is set, get the content for that issue
  useEffect(() => {
    if(activeIssue === null) {
      setActiveContentItem(null)
      setTempActiveIssue(null)
      setWidgetState(WIDGET_STATE.LIST)
      setShowLearnMore(false)
      closeDialog()
      return
    }
  
    setWidgetState(WIDGET_STATE.FIXIT)
    const activeIssueClone = JSON.parse(JSON.stringify(activeIssue))

    activeIssueClone.issueData.initialHtml = Html.getIssueHtml(activeIssueClone.issueData)
    setTempActiveIssue(activeIssueClone)
    
    // If we already downloaded the content for this issue, use that
    const contentItemId = activeIssue.issueData.contentItemId
    if(contentItemCache[contentItemId]) {
      setActiveContentItem(contentItemCache[contentItemId])
    }
    else {
      setActiveContentItem(null)
    }
    setShowLearnMore(false)
    openDialog()

  }, [activeIssue])

  useEffect(() => {
    let tempContentItem = null
    if(activeIssue?.issueData?.contentItemId) {
      tempContentItem = contentItemCache[activeIssue.issueData.contentItemId] || null
    }
    setActiveContentItem(tempContentItem)
  }, [contentItemCache])

  useEffect(() => {
    if(showLearnMore) {
      document.getElementById('btn-learn-more-back')?.focus()
    }
    else {
      document.getElementById('btn-learn-more-open')?.focus()
    }
  }, [showLearnMore])

  const getFilteredContent = (allIssues, includedIssueId = null) => {
    let filteredList = []
    const tempFilters = Object.assign({}, activeFilters)

    // PHPAlly Issues have a 'type' of 'error' or 'suggestion'
    // // Check for easy issues filter
    // if (tempFilters.easyIssues && tempFilters.issueTitles.length == 0) {
    //   tempFilters.issueTitles = easyRules
    // }
    // Loop through the issues

    for (const issue of allIssues) {

      // When we have just saved or resolved an issue, we want to keep that one in the list
      // even if it doesn't match the filters. This is used to show the user that their changes
      // were successful.
      if(includedIssueId && issue.id === includedIssueId) {
        filteredList.push(issue)
        continue
      }

      // Do not include this issue if it doesn't match the severity filter
      if (tempFilters[FILTER.TYPE.SEVERITY] !== FILTER.ALL && tempFilters[FILTER.TYPE.SEVERITY] !== issue.severity) {
        continue
      }

      // Do not include this issue if it doesn't match the content type filter
      let tempContentType = issue.contentType
      let tempStatus = issue.status === FILTER.FIXEDANDRESOLVED ? FILTER.FIXED : issue.status
      if (tempContentType === FILTER.FILE_OBJECT) {
        // When the user selects "Files", show both "File" issues as well as external File objects
        tempContentType = FILTER.FILE
      }
      if (tempFilters[FILTER.TYPE.CONTENT_TYPE] !== FILTER.ALL && tempFilters[FILTER.TYPE.CONTENT_TYPE] !== tempContentType) {
        continue
      }

      // Do not include this issue if it doesn't match the status filter
      if (tempFilters[FILTER.TYPE.RESOLUTION] !== FILTER.ALL && tempFilters[FILTER.TYPE.RESOLUTION] !== tempStatus) {
        continue
      }

      // Do not include this issue if it doesn't match the module filter
      if (tempFilters[FILTER.TYPE.MODULE] !== FILTER.ALL) {
        let sectionId = tempFilters[FILTER.TYPE.MODULE].replace('section-', '')
        if (!issue.sectionIds.includes(sectionId)) {
          continue
        }
      }

      // Do not include this issue if it doesn't match the published filter
      if (tempFilters[FILTER.TYPE.PUBLISHED] !== FILTER.ALL && (tempFilters[FILTER.TYPE.PUBLISHED] === FILTER.PUBLISHED) !== issue.published) {
        continue
      }

      // Do not include this issue if it doesn't contain the search term/s
      if (searchTerm !== '') {
        const searchTerms = searchTerm.toLowerCase().split(' ')
        let containsAllTerms = true
        if (Array.isArray(searchTerms)) {
          for (let term of searchTerms) {
            if (!issue.keywords.includes(term)) {
              containsAllTerms = false
            }
          }
        }
        if (!containsAllTerms) {
          continue
        }
      }

      // Check to see if the user ONLY wants to see issues from published content
      if(settings?.user?.roles?.view_only_published && issue.issueData) {
        let tempContentItem = getContentById(issue.issueData.contentItemId)
        if(tempContentItem && tempContentItem.published === false) {
          continue
        }
      }

      // If the issue passes all filters, add it to the list!
      filteredList.push(issue)
    }

    filteredList.sort((a, b) => {
      return (a.formLabel.toLowerCase() < b.formLabel.toLowerCase()) ? -1 : 1
    })

    return filteredList
  }

  // All local information must be updated to match the new issue state:
  // - activeIssue
  // - unfilteredIssues
  // - filteredIssues
  // This does NOT change the report object, which updates when the issue's data changes.
  const updateActiveSessionIssue = (issueId, state = null, contentItemId = null) => {
    
    if(state === null) {
      state = settings.ISSUE_STATE.UNCHANGED
    }

    // This updates the counter for the daily progress
    updateSessionIssue(issueId, state, contentItemId)

    // Only update the whole list if the issue is saved, resolved, or marked as unresolved.
    if(state === settings.ISSUE_STATE.SAVED
      || state === settings.ISSUE_STATE.RESOLVED
      || state === settings.ISSUE_STATE.UNCHANGED) {

        let tempUnfilteredIssues = unfilteredIssues.map((issue) => {
          if(issue.id === issueId) {
            let tempIssue = Object.assign({}, issue)
            tempIssue.currentState = state
            return tempIssue
          }
          return issue
        })
        setUnfilteredIssues(tempUnfilteredIssues)
        setFilteredIssues(getFilteredContent(tempUnfilteredIssues, activeIssue?.id || null))
    }

    // This updates the active issue to the current state, which allows the proper UI to show
    // (like "Processing..." which disables the buttons).
    if(activeIssue) {
      let tempIssue = activeIssue
      if(tempIssue.id === issueId) {
        tempIssue.currentState = state
        setActiveIssue(tempIssue)
      }
    }
  }

  const getNewFullPageHtml = (content, issue) => {
    if(!content?.body || !issue) {
      return
    }

    // Create the full HTML string for the new version of the content item.
    const parser = new DOMParser()
    const tempDoc = parser.parseFromString(content.body, 'text/html')

    let errorElement = Html.findElementWithIssue(tempDoc, issue)
      
    if(!errorElement) {
      console.warn("Could not find error element when attempting to save...")
      return
    }
    const newElement = Html.toElement(issue?.newHtml)
    
    // Replace or remove the error element
    if(newElement) {
      errorElement.replaceWith(newElement)  
    } else {
      errorElement.remove()
    }

    return tempDoc.body.innerHTML
  }

  const handleIssueSave = () => {

    if(!activeContentItem || !activeContentItem?.body || !tempActiveIssue || !tempActiveIssue?.issueData) {
      return
    }

    let issue = tempActiveIssue.issueData

    updateActiveSessionIssue(issue.id, settings.ISSUE_STATE.SAVING)
    addItemToBeingScanned(issue.contentItemId)

    const specificClassName = `udoit-ignore-${issue.scanRuleId.replaceAll("_", "-")}`
    if (markAsReviewed) {
      if (issue.status === 1) {
        issue.status = 3
        issue.newHtml = Html.toString(Html.addClass(issue.newHtml, specificClassName))
      } else if (issue.status === 0) {
        issue.status = 2
        issue.newHtml = Html.toString(Html.addClass(issue.sourceHtml, specificClassName))
      }
    } else {
      if (issue.status === 3) {
        issue.status = 1
        issue.newHtml = Html.toString(Html.removeClass(issue.newHtml, specificClassName))
      } else if (issue.status === 2) {
        issue.status = 0
        issue.newHtml = Html.toString(Html.removeClass(issue.sourceHtml, specificClassName))
      }
    }

    let fullPageHtml = getNewFullPageHtml(activeContentItem, issue)
    let fullPageDoc = new DOMParser().parseFromString(fullPageHtml, 'text/html')
    let newElement = Html.findElementWithError(fullPageDoc, issue?.newHtml)
    let newXpath = Html.findXpathFromElement(newElement)
    if(newXpath) {
      issue.xpath = newXpath
    }
    else {
      issue.xpath = ""
    }
    activeContentItem.body = fullPageHtml

    // Save the updated issue using the LMS API
    let api = new Api(settings)
    try {
      api.saveIssue(issue, fullPageHtml, markAsReviewed)
      .then((responseStr) => {
        // Check for HTTP errors before parsing JSON
          if (!responseStr.ok) {
            processServerError(responseStr)
            updateActiveSessionIssue(issue.id, settings.ISSUE_STATE.ERROR)
            removeItemFromBeingScanned(issue.contentItemId)
            return null
          }
          return responseStr.json()
      })
      .then((response) => {

        // If the save falied, show the relevant error message
        if (response.data.failed) {
          updateActiveSessionIssue(issue.id, settings.ISSUE_STATE.ERROR)
          removeItemFromBeingScanned(issue.contentItemId)
          response.messages.forEach((msg) => addMessage(msg))
            
          if (Array.isArray(response.data.issues)) {
            response.data.issues.forEach((issue) => {
              addMessage({
                severity: 'error',
                message: t(`form.error.${issue.ruleId}`)
              })
            })
          }

          if (Array.isArray(response.data.errors)) {
            response.data.errors.forEach((error) => {
              addMessage({
                severity: 'error',
                message: error
              })
            })
          }
        }
        else {
          
          // If the save was successful, show the success message
          response.messages.forEach((msg) => addMessage(msg))
          
          if (response.data.issue) {
            // Update the report object by rescanning the content
            const newIssue = Object.assign({}, issue, response.data.issue)
            // const formattedData = formatIssueData(newIssue)
            // setActiveIssue(formattedData)
            updateActiveSessionIssue(newIssue.id, settings.ISSUE_STATE.SAVED)

            api.scanContent(newIssue.contentItemId)
              .then((responseStr) => responseStr.json())
              .then((res) => { 
                const tempReport = Object.assign({}, res?.data)
                processNewReport(tempReport)
                removeItemFromBeingScanned(newIssue.contentItemId)
              })
          }
          else {
            // setActiveIssue(formatIssueData(issue))
            updateActiveSessionIssue(issue.id, settings.ISSUE_STATE.SAVED)
            removeItemFromBeingScanned(issue.contentItemId)
          }
        }
      })
    } catch (error) {
      console.error(error)
      updateActiveSessionIssue(issue.id, settings.ISSUE_STATE.ERROR)
    }
  }

  const updateActiveFilters = (filter, value) => {
    setActiveFilters(Object.assign({}, activeFilters, {[filter]: value}))
  }

  const nextIssue = (previous = false) => {
    if (!activeIssue || filteredIssues.length < 2) { return }
    let activeIndex = filteredIssues.findIndex((issue) => issue.id === activeIssue.id)

    if(activeIndex === -1) { return }

    // If we've reached the first or last issue, loop around
    let newIndex = activeIndex + (previous ? -1 : 1)
    if (newIndex < 0) {
      newIndex = filteredIssues.length - 1
    }
    else if (newIndex >= filteredIssues.length) {
      newIndex = 0
    }
    setActiveIssue(filteredIssues[newIndex])
  }

  const getContentById = (contentId) => {
    if(!report.contentItems[contentId]) {
      return null
    }
    return report.contentItems[contentId]
  }

  const createKeywords = (issue, formName, contentItem) => {
    let keywords = []

    if(formName !== '') {
      keywords.push(formName.toLowerCase())
    }
    if(issue?.scanRuleId) {
      keywords.push(issue.scanRuleId.toLowerCase())
    }
    if(contentItem?.contentType) {
      keywords.push(t(`label.${contentItem.contentType}`).toLowerCase())
    }
    if(contentItem?.title) {
      keywords.push(contentItem.title.toLowerCase())
    }

    return keywords.join(' ')
  }

  const triggerLiveUpdate = () => {
    setLiveUpdateToggle(!liveUpdateToggle)
  }

  const isDialogOpen = () => {
    const dialog = document.getElementById(dialogId)
    return dialog && dialog.open
  }

  const openDialog = () => {
    setWidgetState(WIDGET_STATE.FIXIT)

    const dialog = document.getElementById(dialogId)
    if(dialog) {
      dialog.showModal()
    }
  }

  const closeDialog = () => {
    setWidgetState(WIDGET_STATE.LIST)
    setActiveIssue(null)

    const dialog = document.getElementById(dialogId)
    if(dialog) {
      dialog.close()
    }
  }

  return (
    <>
      { widgetState === WIDGET_STATE.LOADING ? (
        <></>
      ) : (
        <>
          <h1>{t('barriers.title')}</h1>
          <div className="subheader">{t('barriers.subtitle')}</div>

          <FixIssuesFilters
            t={t}
            settings={settings}

            activeFilters={activeFilters}
            handleSearchTerm={setSearchTerm}
            searchTerm={searchTerm}
            sections={sections}
            updateActiveFilters={updateActiveFilters}
          />
          <div className="mt-1 subtext align-self-end">{t('fix.label.barriers_shown_count', { shown: filteredIssues?.length || 0, total: unfilteredIssues?.length || 0 })}</div>
          <FixIssuesList
            t={t}
            settings={settings}

            groupedList={groupedList}
            setActiveIssue={setActiveIssue}
          />
        </>
      ) }
      <dialog id={dialogId} className="dialog-full-screen" onClose={closeDialog}>
        <div className="flex-column h-100">
          <div className="dialog-header">
            <h2>{tempActiveIssue?.formLabel}</h2>
            <CloseIcon
              onClick={closeDialog}
              onKeyDown={(e) => {
                if(e.key === 'Enter' || e.key === ' ') {
                  closeDialog()
                }
              }}
              className="close-icon icon-lg text-color"
              tabIndex="0"
              alt={t('fix.button.close')}
              title={t('fix.button.close')} />
          </div>
          <div className="dialog-content">
            <div className="flex-row w-100 h-100">
              <section className='ufixit-widget-container'>
                { tempActiveIssue && (
                  <>
                    <LearnMore
                      t={t}
                      settings={settings}

                      tempActiveIssue={tempActiveIssue}
                      showLearnMore={showLearnMore}
                      hideLearnMore={() => setShowLearnMore(false)}
                    />
                    
                    <UfixitWidget
                      t={t}
                      settings={settings}

                      activeContentItem={activeContentItem}
                      addMessage={addMessage}
                      handleIssueSave={handleIssueSave}
                      isContentLoading={contentItemsBeingScanned.includes(tempActiveIssue?.issueData?.contentItemId)}
                      isErrorFoundInContent={isErrorFoundInContent}
                      setTempActiveIssue={setTempActiveIssue}
                      tempActiveIssue={tempActiveIssue}
                      triggerLiveUpdate={triggerLiveUpdate}
                      markAsReviewed={markAsReviewed}
                      setMarkAsReviewed={setMarkAsReviewed}
                      setFormInvalid={setFormInvalid}
                      handleLearnMoreClick={() => setShowLearnMore(true)}
                      showLearnMore={showLearnMore}
                    />
                  </>
                )}
              </section>
              <section className="ufixit-content-container">
                {filteredIssues.length > 0 && (
                  <FixIssuesContentPreview
                    t={t}
                    settings={settings}

                    activeContentItem={activeContentItem}
                    activeIssue={tempActiveIssue}
                    contentItemsBeingScanned={contentItemsBeingScanned}
                    liveUpdateToggle={liveUpdateToggle}
                    setIsErrorFoundInContent={setIsErrorFoundInContent}
                  />
                )}
              </section>
            </div>
          </div>
          <div className="dialog-footer">
            <div className="flex-row gap-2 align-items-center">
              <button
                className='btn btn-small btn-link btn-icon-left'
                onClick={() => nextIssue(true)}
                disabled={filteredIssues.length < 2}
                tabIndex="0">
                <LeftArrowIcon className='icon-sm' />
                <div className="align-self-center">{t('fix.button.previous')}</div>
              </button>

              <button
                className='btn btn-small btn-link btn-icon-right'
                onClick={() => nextIssue()}
                disabled={filteredIssues.length < 2}
                tabIndex="0">
                <div className="align-self-center">{t('fix.button.next')}</div>
                <RightArrowIcon className='icon-sm' />
              </button>
            </div>
            <div className="align-self-center">
              <button
                onClick={handleIssueSave}
                className="btn btn-primary btn-icon-left"
                disabled={formInvalid || !isErrorFoundInContent || showLearnMore || contentItemsBeingScanned.includes(tempActiveIssue?.issueData?.contentItemId)}
                tabIndex="0">
                {t('form.submit')}
              </button>
            </div>
          </div>
        </div>
      </dialog>
    </>
  )
}