import React, { useState, useEffect } from 'react'
import FixIssuesFilters from './FixIssuesFilters'
import FixIssuesList from './FixIssuesList'
import FixIssuesContentPreview from './FixIssuesContentPreview'
import UfixitWidget from './UfixitWidget'
import { formNameFromRule } from '../Services/Ufixit'
import * as Html from '../Services/Html'
import Api from '../Services/Api'

import './FixIssuesPage.css'

/** The data for this component can be a bit confusing, so here's a breakdown:
  * - report: The main report object is generated by the scanner.
  * --- report.issues: All of the issues in a format that mirrors the database. Saving a loading is done with this.
  * --- report.files: All of the files in a format that mirrors the database. Saving a loading is done with this.
  * --- report.contentItems: All of the content items in the course. This is used to store the content for each issue.
  * 
  * After the data is brought in through the API, it is formatted in the formatIssueData and formatFileData functions
  * and stored in a list that can be filtered.
  * - unfilteredIssues: A list of all the issues in the course, formatted for the front end.
  * - filteredIssues: A list of the issues that match the current filters and search term.
  * - activeIssue: The issue that is currently being viewed and edited, including non-database attributes
  * --- activeIssue.issueData: The issue as it is stored in the database. Matches report.issues for the issue.
  * --- activeIssue.fileData: The file as it is stored in the database. Matches report.files for the file.
**/

export default function FixIssuesPage({
  t,
  settings,
  initialSeverity = '',
  contentItemList,
  addContentItem,
  report,
  sections,
  setReport,
  addMessage,
  updateReportIssue,
  sessionIssues,
  updateSessionIssue,
  disableReview })
{

  // Define the kinds of filters that will be available to the user
  const FILTER = {
    TYPE: {
      SEVERITY: 'SEVERITY',
      CONTENT_TYPE: 'CONTENT_TYPE',
      RESOLUTION: 'RESOLUTION',
      MODULE: 'MODULE',
    },
    ALL: 'ALL',
    ISSUE: 'ISSUE',
    POTENTIAL: 'POTENTIAL',
    SUGGESTION: 'SUGGESTION',
    PAGE: 'PAGE',
    ASSIGNMENT: 'ASSIGNMENT',
    ANNOUNCEMENT: 'ANNOUNCEMENT',
    DISCUSSION_TOPIC: 'DISCUSSION_TOPIC',
    DISCUSSION_FORUM: 'DISCUSSION_FORUM',
    FILE: 'FILE',
    QUIZ: 'QUIZ',
    SYLLABUS: 'SYLLABUS',
    MODULE: 'MODULE',
    FILE_OBJECT: 'FILE_OBJECT',
    ACTIVE: 'ACTIVE',
    FIXED: 'FIXED',
    RESOLVED: 'RESOLVED',
  }

  const defaultFilters = {
    [FILTER.TYPE.SEVERITY]: FILTER.ALL,
    [FILTER.TYPE.CONTENT_TYPE]: FILTER.ALL,
    [FILTER.TYPE.RESOLUTION]: FILTER.ACTIVE,
    [FILTER.TYPE.MODULE]: FILTER.ALL,
  }

  const WIDGET_STATE = {
    LOADING: 0,
    FIXIT: 1,
    LEARN: 2,
    LIST: 3,
    NO_RESULTS: 4,
  }

  const FILE_TYPES = [
    'pdf',
    'doc',
    'ppt',
    'xls',
  ]

  const [activeIssue, setActiveIssue] = useState(null)
  const [activeContentItem, setActiveContentItem] = useState(null)
  const [editedElement, setEditedElement] = useState(null)
  const [searchTerm, setSearchTerm] = useState('')
  const [activeFilters, setActiveFilters] = useState(defaultFilters)
  const [unfilteredIssues, setUnfilteredIssues] = useState([])
  const [filteredIssues, setFilteredIssues] = useState([])
  const [widgetState, setWidgetState] = useState(WIDGET_STATE.LOADING)
  const [viewInfo, setViewInfo] = useState(false)

  // The database stores and returns certain issue data, but it needs additional attributes in order to
  // be really responsive on the front end. This function adds those attributes and stores the database
  // information in the "issue" attribute.
  const formatIssueData = (issue) => {

    let issueSeverity = FILTER.ISSUE
    // PHPAlly returns a type of 'error' or 'suggestion'
    if(issue.type === 'suggestion' || issue.type === 'SUGGESTION') {
      issueSeverity = FILTER.SUGGESTION
    }
    else if(issue.type === 'potential' || issue.type === 'POTENTIAL' || issue.type === 'MANUAL') {
      issueSeverity = FILTER.POTENTIAL
    }
    
    let issueContentType = FILTER.ALL
    let issueSectionIds = []

    // PHPAlly returns a contentItemId that we can use to get the content type
    let tempContentItem = getContentById(issue.contentItemId)
    if(tempContentItem) {
      let tempContentType = tempContentItem.contentType

      const contentTypeMap = {
        'page': FILTER.PAGE,
        'assignment': FILTER.ASSIGNMENT,
        'announcement': FILTER.ANNOUNCEMENT,
        'discussion_topic': FILTER.DISCUSSION_TOPIC,
        'discussion_forum': FILTER.DISCUSSION_FORUM,
        'file': FILTER.FILE,
        'quiz': FILTER.QUIZ,
        'syllabus': FILTER.SYLLABUS,
        'module': FILTER.MODULE,
      }

      if(contentTypeMap[tempContentType]) {
        issueContentType = contentTypeMap[tempContentType]
      }

      // See if the issue's content is listed in one of the sections

// Canvas Content Item Data:
  // contentType: "page"
  // id: 61
  // lmsContentId: "4-dot-1-2-name-role-value-input-fields"
  // status: true
  // title: "4.1.2 Name, Role, Value - Input Fields"
  // updated: "2025-01-13T13:46:05+00:00"
  // url: "https://canvas.dev.cdl.ucf.edu/courses/383/pages/4-dot-1-2-name-role-value-input-fields"


// Canvas Section Item Data:
  // html_url: "https://canvas.dev.cdl.ucf.edu/courses/383/modules/items/3896"
  // id: 3896
  // indent: 0
  // module_id: 562
  // page_url: "4-dot-1-2-name-role-value-input-fields"
  // position: 1
  // published: true
  // quiz_lti: false
  // title: "4.1.2 Name, Role, Value - Input Fields"
  // type: "Page"
  // url: "https://canvas.dev.cdl.ucf.edu/api/v1/courses/383/pages/4-dot-1-2-name-role-value-input-fields"


      /* TODO: Find a more consistent way to filter this that works with less bespoke data.
        In Canvas, the modules and moduleItems have names and links, but do not have the
        contentItemId, which is necessary to match the issue to the content. The only current
        data that matches are the moduleItem's page_url are the contentItem's lmsContentId,
        which are both the same internal link URL. */
        
      if(sections && sections.length > 0) {
        sections.forEach((section) => {
          let tempSectionId = section.id
          section.items.forEach((item) => {
            if(item.page_url && item.page_url === tempContentItem.lmsContentId) {
              issueSectionIds.push(tempSectionId.toString())
            }
          })
        })
      }
    }

    let issueResolution = FILTER.ACTIVE
    // PHPAlly returns a status of 1 for fixed issues and 2 for resolved issues
    if(issue.status == 1) {
      issueResolution = FILTER.FIXED
    }
    else if(issue.status == 2) {
      issueResolution = FILTER.RESOLVED
    }

    let currentState = settings.ISSUE_STATE.UNCHANGED
    if(sessionIssues && sessionIssues[issue.id]) {
      currentState = sessionIssues[issue.id]
    }

    let formName = formNameFromRule(issue.scanRuleId)
    let formLabel = t(`form.${formName}.title`)

    return {
      issueData: Object.assign({}, issue),
      id: issue.id,
      severity: issueSeverity,
      status: issueResolution,
      sectionIds: issueSectionIds,
      keywords: createKeywords(issue, formLabel, tempContentItem),
      scanRuleId: issue.scanRuleId,
      formName: formName,
      formLabel: formLabel,
      contentId: tempContentItem.lmsContentId,
      contentType: issueContentType,
      contentTitle: tempContentItem.title,
      contentUrl: tempContentItem.url,
      currentState: currentState, 
    }
  }

  const formatFileData = (fileData) => {
    // All files should be considered "Potential Issues" since they need to be reviewed and are
    // not included in the PHPAlly or IBM Equal Access scan.

    let fileId = "file-" + fileData.id

    let issueResolution = FILTER.ACTIVE
    if(fileData.reviewed) {
      issueResolution = FILTER.RESOLVED
    }

    let formLabel = t(`form.file.title`)

    let fileTypeLabel = t(`label.mime.unknown`)
    
    // Guarantee that the keywords include the word "file" in each language
    let keywords = [ fileData.fileName.toLowerCase(), fileTypeLabel.toLowerCase(), formLabel.toLowerCase() ]
    
    // Keywords should include the file type ('MS Word', 'PDF', etc.)
    if(FILE_TYPES.includes(fileData.fileType)) {
      fileTypeLabel = t(`label.mime.${fileData.fileType}`)
      keywords.push[fileTypeLabel.toLowerCase()]
    }

    keywords = keywords.join(' ')

// Canvas File Item Data:
  // active: true
  // downloadUrl: "https://canvas.dev.cdl.ucf.edu/files/13041/download?download_frd=1&verifier=V4WBmWDBfN64x09tieoEqjfKWQWaK0HKXBI0CF54"
  // fileName: "1742314259_587__UCF-_Getting_Started_with_Serverless.pdf"
  // fileSize: "1923148"
  // fileType: "pdf"
  // hidden: false
  // id: 7
  // lmsFileId: "13041"
  // lmsUrl: "https://canvas.dev.cdl.ucf.edu/courses/383/files?preview=13041"
  // reviewed: null
  // status: true
  // updated: "2025-03-18T16:11:00+00:00"

// Canvas Section Item Data:
  // content_id: 13041
  // html_url: "https://canvas.dev.cdl.ucf.edu/courses/383/modules/items/4020"
  // id: 4020
  // indent: 0
  // module_id: 583
  // position: 1
  // published: true
  // quiz_lti: false
  // title: "UCF- Getting Started with Serverless.pdf"
  // type: "File"
  // url: "https://canvas.dev.cdl.ucf.edu/api/v1/courses/383/files/13041"

    let fileSectionIds = []

    if(sections && sections.length > 0) {
      sections.forEach((section) => {
        let tempSectionId = section.id
        section.items.forEach((item) => {
          if(item.content_id && item.content_id.toString() === fileData.lmsFileId.toString()) {
            fileSectionIds.push(tempSectionId.toString())
          }
        })
      })
    }

    let currentState = settings.ISSUE_STATE.UNCHANGED
    if(sessionIssues && sessionIssues[fileId]) {
      currentState = sessionIssues[fileId]
    }

    return {
      fileData: Object.assign({}, fileData),
      id: fileId,
      severity: FILTER.POTENTIAL,
      status: issueResolution,
      sectionIds: fileSectionIds,
      keywords: keywords,
      scanRuleId: 'verify_file_accessibility',
      formLabel: formLabel,
      contentId: fileData.lmsFileId,
      contentType: FILTER.FILE_OBJECT,
      contentTitle: fileData.fileName,
      contentUrl: fileData.lmsUrl,
      currentState: currentState,
    }
  }

  // Call the formatIssueData function when the report changes to make sure every issue has all the necessary attributes
  useEffect(() => {
    let tempIssues = Object.assign({}, report.issues)
    let tempFormattedIssues = []

    for (const [key, value] of Object.entries(tempIssues)) {
      let tempIssue = formatIssueData(value)
      tempFormattedIssues.push(tempIssue)
    }

    let tempFiles = Object.assign({}, report.files)
    for (const [key, value] of Object.entries(tempFiles)) {
      let tempFile = formatFileData(value)
      tempFormattedIssues.push(tempFile)
    }

    tempFormattedIssues.sort((a, b) => {
      return (a.formLabel.toLowerCase() < b.formLabel.toLowerCase()) ? -1 : 1
    })

    setUnfilteredIssues(tempFormattedIssues)
  }, [report])

  // The initialSeverity prop is used when clicking a "Fix Issues" button from the main dashboard.
  useEffect(() => {
    let tempSeverity = initialSeverity || FILTER.ALL
    setActiveFilters(Object.assign({}, defaultFilters, {[FILTER.TYPE.SEVERITY]: tempSeverity}))
  }, [initialSeverity])

  const getFilteredContent = () => {
    let filteredList = []
    const tempFilters = Object.assign({}, activeFilters)

    // PHPAlly Issues have a 'type' of 'error' or 'suggestion'
    // // Check for easy issues filter
    // if (tempFilters.easyIssues && tempFilters.issueTitles.length == 0) {
    //   tempFilters.issueTitles = easyRules
    // }
    // Loop through the issues

    for (const issue of unfilteredIssues) {

      // Do not include this issue if it doesn't match the severity filter
      if (tempFilters[FILTER.TYPE.SEVERITY] !== FILTER.ALL && tempFilters[FILTER.TYPE.SEVERITY] !== issue.severity) {
        continue
      }

      // Do not include this issue if it doesn't match the content type filter
      let tempContentType = issue.contentType
      if (tempContentType === FILTER.FILE_OBJECT) {
        // When the user selects "Files", show both "File" issues as well as external File objects
        tempContentType = FILTER.FILE
      }
      if (tempFilters[FILTER.TYPE.CONTENT_TYPE] !== FILTER.ALL && tempFilters[FILTER.TYPE.CONTENT_TYPE] !== tempContentType) {
        continue
      }

      // Do not include this issue if it doesn't match the status filter
      if (tempFilters[FILTER.TYPE.RESOLUTION] !== FILTER.ALL && tempFilters[FILTER.TYPE.RESOLUTION] !== issue.status) {
        continue
      }

      // Do not include this issue if it doesn't match the module filter
      if (tempFilters[FILTER.TYPE.MODULE] !== FILTER.ALL && !issue.sectionIds.includes(tempFilters[FILTER.TYPE.MODULE].toString())) {
        continue
      }

      // Do not include this issue if it doesn't contain the search term/s
      if (searchTerm !== '') {
        const searchTerms = searchTerm.toLowerCase().split(' ')
        let containsAllTerms = true
        if (Array.isArray(searchTerms)) {
          for (let term of searchTerms) {
            if (!issue.keywords.includes(term)) {
              containsAllTerms = false
            }
          }
        }
        if (!containsAllTerms) {
          continue
        }
      }
      // If the issue passes all filters, add it to the list!
      filteredList.push(issue)
    }

    filteredList.sort((a, b) => {
      return (a.formLabel.toLowerCase() < b.formLabel.toLowerCase()) ? -1 : 1
    })

    return filteredList
  }

  // When the filters or search term changes, update the filtered issues list
  useEffect(() => {

    let tempFilteredContent = getFilteredContent()
    setFilteredIssues(tempFilteredContent)
    setActiveIssue(null)

    // If nothing matches the filters, show the no results view
    if(tempFilteredContent.length === 0) {
      setWidgetState(WIDGET_STATE.NO_RESULTS)
    }
    else {
      // Otherwise, view the list
      setWidgetState(WIDGET_STATE.LIST)
    }

  }, [activeFilters, searchTerm])

  const loadContentItem = (contentItemId) => {
    let api = new Api(settings)
    api.getIssueContent(activeIssue.id)
    .then((response) => {
      return response.json()
    }).then((data) => {
      if(data?.data?.contentItem) {
        const newContentItem = data.data.contentItem
        addContentItem(newContentItem)
        if(activeIssue?.issueData?.contentItemId === contentItemId) {
          setActiveContentItem(newContentItem)
        }
      }
    })
  }

  // When a new activeIssue is set, get the content for that issue
  useEffect(() => {
    if(activeIssue === null) {
      setActiveContentItem(null)
      if(widgetState === WIDGET_STATE.LIST) {
        return
      }
      setWidgetState(WIDGET_STATE.NO_RESULTS)
      return
    }
  
    setWidgetState(WIDGET_STATE.FIXIT)

    if(activeIssue.contentType === FILTER.FILE_OBJECT) {
      setActiveContentItem(null)
      return
    }

    // If we've already downloaded the content for this issue, use that
    const contentItemId = activeIssue.issueData.contentItemId
    if(contentItemList[contentItemId]) {
      setActiveContentItem(contentItemList[contentItemId])
      return
    }

    // Otherwise, clear the old content and download the content for this issue
    setActiveContentItem(null)
    loadContentItem(contentItemId)

  }, [activeIssue])  

  // All local information must be updated to match the new issue state:
  // - activeIssue
  // - unfilteredIssues
  // - filteredIssues
  // This does NOT change the report object, which updates when the issue's data changes.
  const updateActiveSessionIssue = (issueId, state = null) => {

    if(activeIssue) {
      let tempIssue = Object.assign({}, activeIssue)
      if(tempIssue.id === issueId) {
        tempIssue.currentState = state
        setActiveIssue(tempIssue)
      }
    }

    let tempUnfilteredIssues = unfilteredIssues.map((issue) => {
      if(issue.id === issueId) {
        let tempIssue = Object.assign({}, issue)
        tempIssue.currentState = state
        return tempIssue
      }
      return issue
    })
    setUnfilteredIssues(tempUnfilteredIssues)

    let tempFilteredIssues = filteredIssues.map((issue) => {
      if(issue.id === issueId) {
        let tempIssue = Object.assign({}, issue)
        tempIssue.currentState = state
        return tempIssue
      }
      return issue
    })
    setFilteredIssues(tempFilteredIssues)

    // If the issue is resolved or saved, reload the associated content item
    if(state === settings.ISSUE_STATE.SAVED || state === settings.ISSUE_STATE.RESOLVED) {
      let contentItemId = null
      tempUnfilteredIssues.forEach((issue) => {
        if(issue.id === issueId) {
          contentItemId = issue?.issueData?.contentItemId
        }
      })
      if(contentItemId) {
        loadContentItem(contentItemId)
      }
    }

    updateSessionIssue(issueId, state)
  }

  const updateIssue = (newIssueData) => {
    const tempReport = Object.assign({}, report)
    tempReport.issues = tempReport.issues.map((issue) => {
      if (issue.id === newIssueData.id) {
        const tempIssue = formatIssueData(newIssueData)
        if(activeIssue.id === newIssueData.id) {
          setActiveIssue(tempIssue)
        }
        return tempIssue
      }
      return issue
    })
    setReport(tempReport)
  }

  const updateFile = (newFileData) => {
    const tempReport = Object.assign({}, report)

    // Occasionally, the report will send back a list of files in an object instead of an array.
    // It would be nice to use tempReport.files.map, but that doesn't work with objects.
    for (const [key, value] of Object.entries(tempReport.files)) {
      if (key === newFileData.id) {
        const tempFile = formatFileData(newFileData)
        if(activeIssue.id === newFileData.id) {
          setActiveIssue(tempFile)
        }
        tempReport.files[key] = tempFile
      }
    }
    setReport(tempReport)
  }

  const handleIssueSave = (issue) => {

    updateActiveSessionIssue(issue.id, settings.ISSUE_STATE.SAVING)

    // Save the updated issue using the LMS API
    let api = new Api(settings)
    try {
      api.saveIssue(issue)
        .then((responseStr) => responseStr.json())
        .then((response) => {

          // If the save falied, show the relevant error message
          if (response.data.failed) {
            updateActiveSessionIssue(issue.id, settings.ISSUE_STATE.ERROR)
            response.messages.forEach((msg) => addMessage(msg))
            
            if (Array.isArray(response.data.issues)) {
              response.data.issues.forEach((issue) => {
                addMessage({
                  severity: 'error',
                  message: t(`form.error.${issue.ruleId}`)
                })
              })
            }

            if (Array.isArray(response.data.errors)) {
              response.data.errors.forEach((error) => {
                addMessage({
                  severity: 'error',
                  message: error
                })
              })
            }
          }
          else {
            
            // If the save was successful, show the success message
            response.messages.forEach((msg) => addMessage(msg))
            
            if (response.data.issue) {
              // Update the report object by rescanning the content
              const newIssue = Object.assign({}, issue, response.data.issue)
              setActiveIssue(formatIssueData(newIssue))
              updateActiveSessionIssue(newIssue.id, settings.ISSUE_STATE.SAVED)

              api.scanContent(newIssue.contentItemId)
                .then((responseStr) => responseStr.json())
                .then((res) => { 
                  updateReportIssue(newIssue, res.data)
                })
            }
            else {
              setActiveIssue(formatIssueData(issue))
              updateActiveSessionIssue(issue.id, settings.ISSUE_STATE.SAVED)
            }
          }
        })
    } catch (error) {
      console.error(error)
      updateActiveSessionIssue(issue.id, settings.ISSUE_STATE.ERROR)
    }
  }

  /**
   * handleFileUpload is called when a new file has already been selected by the user
   * and is ready to be uploaded to the server and verified.
   */
  const handleFileUpload = (newFileData) => {

    const tempFile = Object.assign({}, activeIssue.fileData)

    updateActiveSessionIssue("file-" + tempFile.id, settings.ISSUE_STATE.SAVING)

    try {
      let api = new Api(settings)
      api.postFile(tempFile, newFileData)
        .then((responsStr) => responsStr.json())
        .then((response) => {
          const updatedFileData = { ...tempFile, ...response.data.file }

          // Set messages 
          response.messages.forEach((msg) => addMessage(msg))

          // Update the local report and activeIssue
          updateActiveSessionIssue("file-" + tempFile.id, settings.ISSUE_STATE.SAVED)
          updateFile(updatedFileData)
        })
    } catch (error) {
      console.error(error)
      updateActiveSessionIssue("file-" + tempFile.id, settings.ISSUE_STATE.ERROR)
    }
  }

  const handleIssueResolve = (issue) => {
    updateActiveSessionIssue(issue.id, settings.ISSUE_STATE.RESOLVING)

    let tempIssue = Object.assign({}, issue)
    if (tempIssue.status) {
      tempIssue.status = false
      tempIssue.newHtml = Html.toString(Html.removeClass(tempIssue.sourceHtml, 'phpally-ignore'))
    }
    else {
      tempIssue.status = 2
      tempIssue.newHtml = Html.toString(Html.addClass(tempIssue.sourceHtml, 'phpally-ignore'))
    }

    // Save the updated issue using the LMS API
    let api = new Api(settings)
    try {
      api.resolveIssue(tempIssue)
        .then((responseStr) => responseStr.json())
        .then((response) => {

          response.messages.forEach((msg) => addMessage(msg))
        
          if (response.data.issue) {
            const newIssue = { ...tempIssue, ...response.data.issue }
            const newReport = response.data.report

            // update activeIssue
            newIssue.sourceHtml = newIssue.newHtml
            newIssue.newHtml = ''
            // Get updated report
            api.scanContent(newIssue.contentItemId)
            .then((responseStr) => responseStr.json())
            .then((res) => {
              // update activeIssue locally
              updateActiveSessionIssue(tempIssue.id, settings.ISSUE_STATE.RESOLVED)
              setActiveIssue(formatIssueData(newIssue))
              updateReportIssue(newIssue, res.data)
            })
          }
          else {
            updateActiveSessionIssue(tempIssue.id, settings.ISSUE_STATE.RESOLVED)
            setActiveIssue(formatIssueData(tempIssue))
          }
        })
    } catch (error) {
      console.error(error)
      updateActiveSessionIssue(issue.id, settings.ISSUE_STATE.ERROR)
    }
  }

  const handleFileResolve = (fileData) => {

    updateActiveSessionIssue("file-" + fileData.id, settings.ISSUE_STATE.RESOLVING)
    
    let tempFile = Object.assign({}, fileData)
    tempFile.reviewed = !(tempFile.reviewed) 

    try {
      let api = new Api(settings)
      api.reviewFile(tempFile)
        .then((responseStr) => responseStr.json())
        .then((response) => {
          const newReport = response.data.report
          const newFileData = { ...tempFile, ...response.data.file }

          // Set messages
          response.messages.forEach((msg) => addMessage(msg))

          // Update the local report and activeIssue
          updateActiveSessionIssue("file-" + fileData.id, settings.ISSUE_STATE.RESOLVED)
          updateFile(newFileData)
        })
    } catch (error) {
      console.error(error)
      updateActiveSessionIssue("file-" + fileData.id, settings.ISSUE_STATE.ERROR)
    }
  }

  const updateActiveFilters = (filter, value) => {
    setActiveFilters(Object.assign({}, activeFilters, {[filter]: value}))
  }

  const nextIssue = (previous = false) => {
    if (!activeIssue || filteredIssues.length < 2) { return }
    let activeIndex = filteredIssues.findIndex((issue) => issue.id === activeIssue.id)

    if(activeIndex === -1) { return }

    // If we've reached the first or last issue, loop around
    let newIndex = activeIndex + (previous ? -1 : 1)
    if (newIndex < 0) {
      newIndex = filteredIssues.length - 1
    }
    else if (newIndex >= filteredIssues.length) {
      newIndex = 0
    }
    setActiveIssue(filteredIssues[newIndex])
    setViewInfo(false)
  }

  const toggleListView = () => {
    if (widgetState === WIDGET_STATE.LIST) {
      if(activeIssue) {
        setWidgetState(WIDGET_STATE.FIXIT)
      }
      else {
        setWidgetState(WIDGET_STATE.NO_RESULTS)
      }
    }
    else {
      setWidgetState(WIDGET_STATE.LIST)
      setViewInfo(false)
      setActiveIssue(null)
      setActiveContentItem(null)
    }
  }

  const getContentById = (contentId) => {
    return Object.assign({}, report.contentItems[contentId])
  }

  const createKeywords = (issue, formName, contentItem) => {
    let keywords = []

    if(formName !== '') {
      keywords.push(formName.toLowerCase())
    }
    if(contentItem?.contentType) {
      keywords.push(t(`label.${contentItem.contentType}`).toLowerCase())
    }
    if(contentItem?.title) {
      keywords.push(contentItem.title.toLowerCase())
    }

    return keywords.join(' ')
  }

  return (
    <>
      <FixIssuesFilters
        t={t}
        settings={settings.FILTER ? settings : Object.assign({}, settings, { FILTER })}
        sections={sections}
        activeFilters={activeFilters}
        updateActiveFilters={updateActiveFilters}
        searchTerm={searchTerm}
        handleSearchTerm={setSearchTerm}
      />
      <div className="ufixit-page-divider">
        <section className="ufixit-widget-container">
          { widgetState === WIDGET_STATE.LIST ? (
            <FixIssuesList
              t={t}
              settings={settings.FILTER ? settings : Object.assign({}, settings, { FILTER })}
              filteredIssues={filteredIssues}
              setActiveIssue={setActiveIssue}
            />
          ) : activeIssue ? (  
              <UfixitWidget
                t={t}
                settings={settings.FILTER ? settings : Object.assign({}, settings, { FILTER })}
                viewInfo={viewInfo}
                setViewInfo={setViewInfo}
                severity={activeIssue.severity}
                activeIssue={activeIssue}
                setActiveIssue={setActiveIssue}
                setEditedElement={setEditedElement}
                formatIssueData={formatIssueData}
                handleIssueResolve={handleIssueResolve}
                handleIssueSave={handleIssueSave}
                handleFileResolve={handleFileResolve}
                handleFileUpload={handleFileUpload}
                toggleListView={toggleListView}
                listLength={filteredIssues.length}
                nextIssue={nextIssue}
              />
          ) : (
            <div className="flex-column gap-3 mt-3">
              <div className="flex-row align-self-center ms-3 me-3">
                <h2 className="mt-0 mb-0 primary-dark">{t('report.label.no_results')}</h2>
              </div>
              <div className="flex-row align-self-center ms-3 me-3">
                {t('report.msg.no_results')}
              </div>
            </div>
          )}
        </section>
        <section className="ufixit-content-container">
          <FixIssuesContentPreview
            t={t}
            settings={settings.FILTER ? settings : Object.assign({}, settings, { FILTER })}
            activeIssue={activeIssue}
            activeContentItem={activeContentItem}
            editedElement={editedElement}
            sessionIssues={sessionIssues}
          />
        </section>
      </div>
    </>
  )
}