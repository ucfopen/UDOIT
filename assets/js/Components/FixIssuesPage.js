import React, { useState, useEffect } from 'react'
import FixIssuesFilters from './Widgets/FixIssuesFilters'
import FixIssuesList from './Widgets/FixIssuesList'
import UfixitWidget from './Widgets/UfixitWidget'
import FixIssuesContentPreview from './Widgets/FixIssuesContentPreview'
import LeftArrowIcon from './Icons/LeftArrowIcon'
import RightArrowIcon from './Icons/RightArrowIcon'
import { formNameFromRule } from '../Services/Ufixit'
import * as Html from '../Services/Html'
import Api from '../Services/Api'

import './FixIssuesPage.css'

/** The data for this component can be a bit confusing, so here's a breakdown:
  * - report: The main report object is generated by the scanner.
  * --- report.issues: All of the issues in a format that mirrors the database. Saving a loading is done with this.
  * --- report.files: All of the files in a format that mirrors the database. Saving a loading is done with this.
  * --- report.contentItems: All of the content items in the course. This is used to store the content for each issue.
  * 
  * After the data is brought in through the API, it is formatted in the formatIssueData and formatFileData functions
  * and stored in a list that can be filtered.
  * - unfilteredIssues: A list of all the issues in the course, formatted for the front end.
  * - filteredIssues: A list of the issues that match the current filters and search term.
  * - activeIssue: The issue that is currently being viewed and edited, including non-database attributes
  * --- activeIssue.issueData: The issue as it is stored in the database. Matches report.issues for the issue.
  * --- activeIssue.fileData: The file as it is stored in the database. Matches report.files for the file.
**/

export default function FixIssuesPage({
  t,
  settings,
  initialSeverity = '',
  initialSearchTerm = '',
  contentItemCache,
  addContentItemToCache,
  report,
  sections,
  processNewReport,
  addMessage,
  sessionIssues,
  updateSessionIssue,
  processServerError
})
{

  // Define the kinds of filters that will be available to the user
  const FILTER = settings.ISSUE_FILTER

  const defaultFilters = {
    [FILTER.TYPE.SEVERITY]: FILTER.ALL,
    [FILTER.TYPE.PUBLISHED]: FILTER.PUBLISHED,
    [FILTER.TYPE.CONTENT_TYPE]: FILTER.ALL,
    [FILTER.TYPE.RESOLUTION]: FILTER.ACTIVE,
    [FILTER.TYPE.MODULE]: FILTER.ALL,
  }

  const defaultNoFilters = {
    [FILTER.TYPE.SEVERITY]: FILTER.ALL,
    [FILTER.TYPE.PUBLISHED]: FILTER.ALL,
    [FILTER.TYPE.CONTENT_TYPE]: FILTER.ALL,
    [FILTER.TYPE.RESOLUTION]: FILTER.ALL,
    [FILTER.TYPE.MODULE]: FILTER.ALL,
  }

  const [activeIssue, setActiveIssue] = useState(null)
  const [tempActiveIssue, setTempActiveIssue] = useState(null)
  const [activeContentItem, setActiveContentItem] = useState(null)
  const [contentItemsBeingScanned, setContentItemsBeingScanned] = useState([])
  const [isErrorFoundInContent, setIsErrorFoundInContent] = useState(false)
  const [searchTerm, setSearchTerm] = useState('')
  const [activeFilters, setActiveFilters] = useState(defaultFilters)
  const [unfilteredIssues, setUnfilteredIssues] = useState([])
  const [filteredIssues, setFilteredIssues] = useState([])
  const [groupedList, setGroupedList] = useState([])
  const [widgetState, setWidgetState] = useState(settings.WIDGET_STATE.LOADING)
  const [liveUpdateToggle, setLiveUpdateToggle] = useState(true)

  // The database stores and returns certain issue data, but it needs additional attributes in order to
  // be really responsive on the front end. This function adds those attributes and stores the database
  // information in the "issue" attribute.
  const formatIssueData = (issue) => {

    let issueSeverity = FILTER.ISSUE
    // PHPAlly returns a type of 'error' or 'suggestion'
    if(issue.type === 'suggestion' || issue.type === 'SUGGESTION') {
      issueSeverity = FILTER.SUGGESTION
    }
    else if(issue.type === 'potential' || issue.type === 'POTENTIAL' || issue.type === 'MANUAL') {
      issueSeverity = FILTER.POTENTIAL
    }
    
    let issueContentType = FILTER.ALL
    let issueSectionIds = []
    let published = true

    // PHPAlly returns a contentItemId that we can use to get the content type
    let tempContentItem = getContentById(issue.contentItemId)
    if(tempContentItem) {
      let tempContentType = tempContentItem.contentType

      const contentTypeMap = {
        'page': FILTER.PAGE,
        'assignment': FILTER.ASSIGNMENT,
        'announcement': FILTER.ANNOUNCEMENT,
        'discussion_topic': FILTER.DISCUSSION_TOPIC,
        'discussion_forum': FILTER.DISCUSSION_FORUM,
        'file': FILTER.FILE,
        'quiz': FILTER.QUIZ,
        'syllabus': FILTER.SYLLABUS,
        'module': FILTER.MODULE,
      }

      if(contentTypeMap[tempContentType]) {
        issueContentType = contentTypeMap[tempContentType]
      }

      // See if the issue's content is listed in one of the sections

      issueSectionIds = tempContentItem.sections || []

      if(tempContentItem.published === false) {
        published = false
      }
    }

    let issueResolution = FILTER.ACTIVE
    // PHPAlly returns a status of 1 for fixed issues and 2 for resolved issues
    if(issue.status == 1) {
      issueResolution = FILTER.FIXED
    }
    else if(issue.status == 2) {
      issueResolution = FILTER.RESOLVED
    }
    else if(issue.status === 3) {
      issueResolution = FILTER.FIXEDANDRESOLVED
    }

    let currentState = settings.ISSUE_STATE.UNCHANGED
    if(sessionIssues && sessionIssues[issue.id]) {
      currentState = sessionIssues[issue.id]
    }

    let formName = formNameFromRule(issue.scanRuleId)
    let formLabel = t(`form.${formName}.title`)

    return {
      issueData: Object.assign({}, issue, { contentUrl: tempContentItem?.url || '' }),
      id: issue.id,
      severity: issueSeverity,
      status: issueResolution,
      published: published,
      sectionIds: issueSectionIds,
      keywords: createKeywords(issue, formLabel, tempContentItem),
      scanRuleId: issue.scanRuleId,
      formName: formName,
      formLabel: formLabel,
      contentId: tempContentItem.lmsContentId,
      contentType: issueContentType,
      contentTitle: tempContentItem.title,
      contentUrl: tempContentItem.url,
      currentState: currentState, 
    }
  }

  const addItemToBeingScanned = (contentItemId) => {
    let tempContentItems = contentItemsBeingScanned
    if(!tempContentItems.includes(contentItemId)) {
      tempContentItems.push(contentItemId)
      setContentItemsBeingScanned(tempContentItems)
    }
  }

  const removeItemFromBeingScanned = (contentItemId) => {
    let tempContentItems = contentItemsBeingScanned
    if(tempContentItems.includes(contentItemId)) {
      tempContentItems = tempContentItems.filter((item) => item !== contentItemId)
      setContentItemsBeingScanned(tempContentItems)
    }
  }

  const groupList = (tempFilteredContent) => {
    const tempGroupedList = []

    // Get all of the issues' "formLabel" values
    const formLabels = tempFilteredContent.map((issue) => issue.formLabel)
    const uniqueFormLabels = [...new Set(formLabels)]

    uniqueFormLabels.sort((a, b) => {
      return (a.toLowerCase() < b.toLowerCase()) ? -1 : 1
    })

    // Group the issues by "formLabel"
    uniqueFormLabels.forEach((formLabel) => {
      const issues = tempFilteredContent.filter((issue) => issue.formLabel === formLabel)
      tempGroupedList.push({ formLabel: formLabel, issues })
    })

    return tempGroupedList
  }

  // The initialSeverity prop is used when clicking a "Fix Issues" button from the main dashboard.
  useEffect(() => {
    let tempSeverity = initialSeverity || FILTER.ALL
    if(initialSearchTerm) {
      setSearchTerm(initialSearchTerm)
      setActiveFilters(Object.assign({}, defaultNoFilters))
    }
    else {
      setActiveFilters(Object.assign({}, defaultFilters, {[FILTER.TYPE.SEVERITY]: tempSeverity}))
    }
  }, [])

  // When the filters or search term changes, update the filtered issues list
  useEffect(() => {

    let tempFilteredContent = getFilteredContent(unfilteredIssues)
    setFilteredIssues(tempFilteredContent)
    setGroupedList(groupList(tempFilteredContent))

    setWidgetState(settings.WIDGET_STATE.LIST)

  }, [activeFilters, searchTerm])

  // The report object is updated whenever a scan or rescan is completed. At this point, the list of issues
  // needs to be rebuilt and the activeIssue may need to be updated. For instance, if an issue is marked as
  // unreviewed then it will be deleted during the rescan and a new issue with a new id will take its place.
  useEffect(() => {
    let tempIssues = Object.assign({}, report.issues)
    let tempUnfilteredIssues = []

    for (const [key, value] of Object.entries(tempIssues)) {
      let tempIssue = formatIssueData(value)
      tempUnfilteredIssues.push(tempIssue)
    }

    // let tempFiles = Object.assign({}, report.files)
    // for (const [key, value] of Object.entries(tempFiles)) {
    //   let tempFile = formatFileData(value)
    //   tempUnfilteredIssues.push(tempFile)
    // }

    tempUnfilteredIssues.sort((a, b) => {
      return (a.formLabel.toLowerCase() < b.formLabel.toLowerCase()) ? -1 : 1
    })

    // Every time the list changes, we need to reload the activeContentItem. This will come from the
    // cache (contentItemCache) or from the database, if not in the cache.
    setActiveContentItem(null)

    // The filtered list should ALWAYS include the current activeIssue, even if it no longer matches
    // the filters. For instance, if I'm only looking through "Unreviewed" issues, and I click on the
    // "Mark as Reviewed" button, that newly-reviewed issue should be available to stay on screen.
    let holdoverActiveIssue = null

    // If there is an activeIssue, we need to connect it to something in the new list of issues.
    if(activeIssue) {  
      // Quick check: is the old activeIssue still in the list?
      tempUnfilteredIssues.forEach((issue) => {
        if(issue.id === activeIssue.id) {
          holdoverActiveIssue = issue
        }
      })

      // If not, we need to do a more thorough check.
      if(holdoverActiveIssue === null) {
        if(activeIssue.contentType === FILTER.FILE_OBJECT) {
          tempUnfilteredIssues.forEach((issue) => {
            if(issue.contentId === activeIssue.contentId) {
              holdoverActiveIssue = issue
            }
          })
        }
        else {
          tempUnfilteredIssues.forEach((issue) => {
            if(issue.scanRuleId === activeIssue.scanRuleId &&
                issue.contentId === activeIssue.contentId &&
                issue.issueData.xpath === activeIssue.issueData.xpath) {
              updateActiveSessionIssue(issue.id, null, issue.issueData.contentItemId)
              holdoverActiveIssue = issue
            }
          })
        }
      }

      if(holdoverActiveIssue === null) {
        setWidgetState(settings.WIDGET_STATE.LIST)
      }
    }

    setUnfilteredIssues(tempUnfilteredIssues)
    let tempFilteredContent = getFilteredContent(tempUnfilteredIssues, holdoverActiveIssue?.id || null)

    setFilteredIssues(tempFilteredContent)
    setGroupedList(groupList(tempFilteredContent))
    if(holdoverActiveIssue) {
      setActiveIssue(holdoverActiveIssue)
    }
    
  }, [report])


  // When a new activeIssue is set, get the content for that issue
  useEffect(() => {
    if(activeIssue === null) {
      setActiveContentItem(null)
      setTempActiveIssue(null)
      setWidgetState(settings.WIDGET_STATE.LIST)
      return
    }
  
    setWidgetState(settings.WIDGET_STATE.FIXIT)
    const activeIssueClone = JSON.parse(JSON.stringify(activeIssue))

    if(activeIssue.contentType === FILTER.FILE_OBJECT) {
      setTempActiveIssue(activeIssueClone)
      setActiveContentItem(null)
      setIsErrorFoundInContent(true)
      return
    }

    activeIssueClone.issueData.initialHtml = Html.getIssueHtml(activeIssueClone.issueData)
    setTempActiveIssue(activeIssueClone)

    // If we've already downloaded the content for this issue, use that
    const contentItemId = activeIssue.issueData.contentItemId
    if(contentItemCache[contentItemId]) {
      setActiveContentItem(contentItemCache[contentItemId])
      return
    }

    // Otherwise, clear the old content and download the content for this issue
    setActiveContentItem(null)
    loadContentItemByIssue(activeIssue)

  }, [activeIssue])

  useEffect(() => {
    let tempContentItem = null
    if(activeIssue?.issueData?.contentItemId) {
      tempContentItem = contentItemCache[activeIssue.issueData.contentItemId] || null
    }
    setActiveContentItem(tempContentItem)
  }, [contentItemCache])

  const getFilteredContent = (allIssues, includedIssueId = null) => {
    let filteredList = []
    const tempFilters = Object.assign({}, activeFilters)

    // PHPAlly Issues have a 'type' of 'error' or 'suggestion'
    // // Check for easy issues filter
    // if (tempFilters.easyIssues && tempFilters.issueTitles.length == 0) {
    //   tempFilters.issueTitles = easyRules
    // }
    // Loop through the issues

    for (const issue of allIssues) {

      // When we have just saved or resolved an issue, we want to keep that one in the list
      // even if it doesn't match the filters. This is used to show the user that their changes
      // were successful.
      if(includedIssueId && issue.id === includedIssueId) {
        filteredList.push(issue)
        continue
      }

      // Do not include this issue if it doesn't match the severity filter
      if (tempFilters[FILTER.TYPE.SEVERITY] !== FILTER.ALL && tempFilters[FILTER.TYPE.SEVERITY] !== issue.severity) {
        continue
      }

      // Do not include this issue if it doesn't match the content type filter
      let tempContentType = issue.contentType
      let tempStatus = issue.status === FILTER.FIXEDANDRESOLVED ? FILTER.FIXED : issue.status
      if (tempContentType === FILTER.FILE_OBJECT) {
        // When the user selects "Files", show both "File" issues as well as external File objects
        tempContentType = FILTER.FILE
      }
      if (tempFilters[FILTER.TYPE.CONTENT_TYPE] !== FILTER.ALL && tempFilters[FILTER.TYPE.CONTENT_TYPE] !== tempContentType) {
        continue
      }

      // Do not include this issue if it doesn't match the status filter
      if (tempFilters[FILTER.TYPE.RESOLUTION] !== FILTER.ALL && tempFilters[FILTER.TYPE.RESOLUTION] !== tempStatus) {
        continue
      }

      // Do not include this issue if it doesn't match the module filter
      if (tempFilters[FILTER.TYPE.MODULE] !== FILTER.ALL) {
        let sectionId = tempFilters[FILTER.TYPE.MODULE].replace('section-', '')
        if (!issue.sectionIds.includes(sectionId)) {
          continue
        }
      }

      // Do not include this issue if it doesn't match the published filter
      if (tempFilters[FILTER.TYPE.PUBLISHED] !== FILTER.ALL && (tempFilters[FILTER.TYPE.PUBLISHED] === FILTER.PUBLISHED) !== issue.published) {
        continue
      }

      // Do not include this issue if it doesn't contain the search term/s
      if (searchTerm !== '') {
        const searchTerms = searchTerm.toLowerCase().split(' ')
        let containsAllTerms = true
        if (Array.isArray(searchTerms)) {
          for (let term of searchTerms) {
            if (!issue.keywords.includes(term)) {
              containsAllTerms = false
            }
          }
        }
        if (!containsAllTerms) {
          continue
        }
      }

      // Check to see if the user ONLY wants to see issues from published content
      if(settings?.user?.roles?.view_only_published && issue.issueData) {
        let tempContentItem = getContentById(issue.issueData.contentItemId)
        if(tempContentItem && tempContentItem.published === false) {
          continue
        }
      }

      // If the issue passes all filters, add it to the list!
      filteredList.push(issue)
    }

    filteredList.sort((a, b) => {
      return (a.formLabel.toLowerCase() < b.formLabel.toLowerCase()) ? -1 : 1
    })

    return filteredList
  }

  const loadContentItemByIssue = (issue) => {
    let contentItemId = issue?.issueData?.contentItemId || null
    if(contentItemId) {
      addItemToBeingScanned(contentItemId)
      let api = new Api(settings)
      api.getIssueContent(issue.id)
      .then((response) => {
        return response.json()
      }).then((data) => {
        if(data?.data?.contentItem) {
          const newContentItem = data.data.contentItem
          addContentItemToCache(newContentItem)
        }
        removeItemFromBeingScanned(contentItemId)
      })
    }
  }


  // All local information must be updated to match the new issue state:
  // - activeIssue
  // - unfilteredIssues
  // - filteredIssues
  // This does NOT change the report object, which updates when the issue's data changes.
  const updateActiveSessionIssue = (issueId, state = null, contentItemId = null) => {
    
    if(state === null) {
      state = settings.ISSUE_STATE.UNCHANGED
    }

    // This updates the counter for the daily progress
    updateSessionIssue(issueId, state, contentItemId)

    // Only update the whole list if the issue is saved, resolved, or marked as unresolved.
    if(state === settings.ISSUE_STATE.SAVED
      || state === settings.ISSUE_STATE.RESOLVED
      || state === settings.ISSUE_STATE.UNCHANGED) {

        let tempUnfilteredIssues = unfilteredIssues.map((issue) => {
          if(issue.id === issueId) {
            let tempIssue = Object.assign({}, issue)
            tempIssue.currentState = state
            return tempIssue
          }
          return issue
        })
        setUnfilteredIssues(tempUnfilteredIssues)
        setFilteredIssues(getFilteredContent(tempUnfilteredIssues, activeIssue?.id || null))
    }

    // This updates the active issue to the current state, which allows the proper UI to show
    // (like "Processing..." which disables the buttons).
    if(activeIssue) {
      let tempIssue = activeIssue
      if(tempIssue.id === issueId) {
        tempIssue.currentState = state
        setActiveIssue(tempIssue)
      }
    }
  }

  const getNewFullPageHtml = (content, issue) => {
    if(!content?.body || !issue) {
      return
    }

    // Create the full HTML string for the new version of the content item.
    const parser = new DOMParser()
    const tempDoc = parser.parseFromString(content.body, 'text/html')

    let errorElement = Html.findElementWithIssue(tempDoc, issue)
      
    if(!errorElement) {
      console.warn("Could not find error element when attempting to save...")
      return
    }
    const newElement = Html.toElement(issue?.newHtml)
    
    // Replace or remove the error element
    if(newElement) {
      errorElement.replaceWith(newElement)  
    } else {
      errorElement.remove()
    }

    return tempDoc.body.innerHTML
  }

  const handleIssueSave = async (issue, markAsReviewed = false) => {

    if(!activeContentItem || !activeContentItem?.body || !issue) {
      return
    }

    updateActiveSessionIssue(issue.id, settings.ISSUE_STATE.SAVING)
    addItemToBeingScanned(issue.contentItemId)

    const specificClassName = `udoit-ignore-${issue.scanRuleId.replaceAll("_", "-")}`
    if (markAsReviewed) {
      if (issue.status === 1) {
        issue.status = 3
        issue.newHtml = Html.toString(Html.addClass(issue.newHtml, specificClassName))
      } else if (issue.status === 0) {
        issue.status = 2
        issue.newHtml = Html.toString(Html.addClass(issue.sourceHtml, specificClassName))
      }
    } else {
      if (issue.status === 3) {
        issue.status = 1
        issue.newHtml = Html.toString(Html.removeClass(issue.newHtml, specificClassName))
      } else if (issue.status === 2) {
        issue.status = 0
        issue.newHtml = Html.toString(Html.removeClass(issue.sourceHtml, specificClassName))
      }
    }

    let fullPageHtml = getNewFullPageHtml(activeContentItem, issue)
    let fullPageDoc = new DOMParser().parseFromString(fullPageHtml, 'text/html')
    let newElement = Html.findElementWithError(fullPageDoc, issue?.newHtml)
    let newXpath = Html.findXpathFromElement(newElement)
    issue.xpath = newXpath || ''
    
    // Save the updated issue using the LMS API
    let api = new Api(settings)
    try {
      const saveResponse = await api.saveIssue(issue, fullPageHtml, markAsReviewed)
      if(!saveResponse.ok){
        processServerError(saveResponse)
        updateActiveSessionIssue(issue.id, settings.ISSUE_STATE.ERROR)
        removeItemFromBeingScanned(issue.contentItemId)
        throw Error('Save returned invalid server response.')
      }

      const saveResponseJson = await saveResponse.json()

      if(saveResponseJson?.errors && saveResponseJson.errors.length > 0) {
        updateActiveSessionIssue(issue.id, settings.ISSUE_STATE.ERROR)
        removeItemFromBeingScanned(issue.contentItemId)
        saveResponseJson.messages.forEach((msg) => addMessage(msg))

        if (Array.isArray(saveResponseJson.errors)) {
          saveResponseJson.errors.forEach((error) => {
            addMessage({
              severity: 'error',
              message: t(error)
            })
          })
        }
        throw Error('Save failed.')
      }

      // Successful save!
      saveResponseJson.messages.forEach((msg) => addMessage(msg))
      if(issue.contentItemId === activeContentItem.id) {
        activeContentItem.body = fullPageHtml
      }

      // If there isn't a new issue created, we're done.
      if(!saveResponseJson?.data?.issue) {
        updateActiveSessionIssue(issue.id, settings.ISSUE_STATE.SAVED)
        removeItemFromBeingScanned(issue.contentItemId)
        return
      }

      if(saveResponseJson?.data?.issue) {
        // Update the report object by rescanning the content
        const newIssue = Object.assign({}, issue, saveResponseJson.data.issue)
        updateActiveSessionIssue(newIssue.id, settings.ISSUE_STATE.SAVED)

        const scanResponse = await api.scanContent(newIssue.contentItemId)

        if(scanResponse.ok) {
          const scanResponseJson = await scanResponse.json()
          if(scanResponseJson.data) {
            const tempReport = Object.assign({}, scanResponseJson.data)
            processNewReport(tempReport)
            removeItemFromBeingScanned(newIssue.contentItemId)
            return
          }
        }
      }

      updateActiveSessionIssue(issue.id, settings.ISSUE_STATE.SAVED)
      removeItemFromBeingScanned(issue.contentItemId)

    } catch (error) {
      console.warn(error)
      updateActiveSessionIssue(issue.id, settings.ISSUE_STATE.ERROR)
    }
  }

  const updateActiveFilters = (filter, value) => {
    setActiveFilters(Object.assign({}, activeFilters, {[filter]: value}))
  }

  const nextIssue = (previous = false) => {
    if (!activeIssue || filteredIssues.length < 2) { return }
    let activeIndex = filteredIssues.findIndex((issue) => issue.id === activeIssue.id)

    if(activeIndex === -1) { return }

    // If we've reached the first or last issue, loop around
    let newIndex = activeIndex + (previous ? -1 : 1)
    if (newIndex < 0) {
      newIndex = filteredIssues.length - 1
    }
    else if (newIndex >= filteredIssues.length) {
      newIndex = 0
    }
    setActiveIssue(filteredIssues[newIndex])
  }

  const toggleListView = () => {
    if (widgetState === settings.WIDGET_STATE.LIST) {
      if(activeIssue) {
        setWidgetState(settings.WIDGET_STATE.FIXIT)
      }
      else {
        setWidgetState(settings.WIDGET_STATE.NO_RESULTS)
      }
    }
    else {
      setWidgetState(settings.WIDGET_STATE.LIST)
      setActiveIssue(null)
      setActiveContentItem(null)
    }
  }

  const getContentById = (contentId) => {
    if(!report.contentItems[contentId]) {
      return null
    }
    return report.contentItems[contentId]
  }

  const createKeywords = (issue, formName, contentItem) => {
    let keywords = []

    if(formName !== '') {
      keywords.push(formName.toLowerCase())
    }
    if(issue?.scanRuleId) {
      keywords.push(issue.scanRuleId.toLowerCase())
    }
    if(contentItem?.contentType) {
      keywords.push(t(`label.${contentItem.contentType}`).toLowerCase())
    }
    if(contentItem?.title) {
      keywords.push(contentItem.title.toLowerCase())
    }

    return keywords.join(' ')
  }

  const triggerLiveUpdate = () => {
    setLiveUpdateToggle(!liveUpdateToggle)
  }

  return (
    <>
      { widgetState === settings.WIDGET_STATE.LOADING ? (
        <></>
      ) : widgetState === settings.WIDGET_STATE.LIST ? (
        <>
          <FixIssuesFilters
            t={t}
            settings={settings}

            activeFilters={activeFilters}
            handleSearchTerm={setSearchTerm}
            searchTerm={searchTerm}
            sections={sections}
            updateActiveFilters={updateActiveFilters}
          />
          <FixIssuesList
            t={t}
            settings={settings}

            groupedList={groupedList}
            setActiveIssue={setActiveIssue}
          />
        </>
      ) : (
        <div className="flex-row gap-2 w-100 h-100">
          <section className='ufixit-widget-container'>
            <button onClick={toggleListView} className="btn btn-link btn-icon-left btn-small mb-2">
              <LeftArrowIcon className="icon-sm link-color" />{t('fix.button.list')}
            </button>
            { tempActiveIssue ? (  
                <UfixitWidget
                  t={t}
                  settings={settings}

                  activeContentItem={activeContentItem}
                  addMessage={addMessage}
                  handleIssueSave={handleIssueSave}
                  isContentLoading={contentItemsBeingScanned.includes(tempActiveIssue?.issueData?.contentItemId)}
                  isErrorFoundInContent={isErrorFoundInContent}
                  setTempActiveIssue={setTempActiveIssue}
                  tempActiveIssue={tempActiveIssue}
                  triggerLiveUpdate={triggerLiveUpdate}
                />
            ) : ''}
          </section>
          <section className="ufixit-content-container">
            {filteredIssues.length > 0 && (
              <FixIssuesContentPreview
                t={t}
                settings={settings}

                activeContentItem={activeContentItem}
                activeIssue={tempActiveIssue}
                contentItemsBeingScanned={contentItemsBeingScanned}
                liveUpdateToggle={liveUpdateToggle}
                setIsErrorFoundInContent={setIsErrorFoundInContent}
              />
            )}
            <div className="flex-row justify-content-end gap-2 mt-3">
              <button
                className={`btn btn-small btn-link btn-icon-left ${filteredIssues.length < 2 ? 'disabled' : ''}`}
                onClick={() => nextIssue(true)}
                tabIndex="0">
                <LeftArrowIcon className={`icon-sm ` + (filteredIssues.length < 2 ? 'gray' : 'link-color')} />
                <div className="flex-column justify-content-center">{t('fix.button.previous')}</div>
              </button>

              <button
                className={`btn btn-small btn-link btn-icon-right ${filteredIssues.length < 2 ? 'disabled' : ''}`}
                onClick={() => nextIssue()}
                tabIndex="0">
                <div className="flex-column justify-content-center">{t('fix.button.next')}</div>
                <RightArrowIcon className={`icon-sm ` + (filteredIssues.length < 2 ? 'gray' : 'link-color')} />
              </button>
            </div>
          </section>
        </div>
      )}
    </>
  )
}