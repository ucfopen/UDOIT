import React, { useState, useEffect } from 'react'
import FixIssuesFilters from './Widgets/FixIssuesFilters'
import SortableTable from './Widgets/SortableTable'
import FixIssuesList from './Widgets/FixIssuesList'
import UfixitWidget from './Widgets/UfixitWidget'
import FixIssuesContentPreview from './Widgets/FixIssuesContentPreview'
import LeftArrowIcon from './Icons/LeftArrowIcon'
import RightArrowIcon from './Icons/RightArrowIcon'
import { formNameFromRule } from '../Services/Ufixit'
import * as Html from '../Services/Html'
import * as Text from '../Services/Text'
import Api from '../Services/Api'

import './FixIssuesPage.css'

/** The data for this component can be a bit confusing, so here's a breakdown:
  * - report: The main report object is generated by the scanner.
  * --- report.issues: All of the issues in a format that mirrors the database. Saving a loading is done with this.
  * --- report.files: All of the files in a format that mirrors the database. Saving a loading is done with this.
  * --- report.contentItems: All of the content items in the course. This is used to store the content for each issue.
  * 
  * After the data is brought in through the API, it is formatted in the formatIssueData and formatFileData functions
  * and stored in a list that can be filtered.
  * - unfilteredIssues: A list of all the issues in the course, formatted for the front end.
  * - filteredIssues: A list of the issues that match the current filters and search term.
  * - activeIssue: The issue that is currently being viewed and edited, including non-database attributes
  * --- activeIssue.issueData: The issue as it is stored in the database. Matches report.issues for the issue.
  * --- activeIssue.fileData: The file as it is stored in the database. Matches report.files for the file.
**/

export default function ReviewFilesPage({
  t,
  settings,
  initialSeverity = '',
  initialSearchTerm = '',
  contentItemCache,
  addContentItemToCache,
  report,
  sections,
  processNewReport,
  addMessage,
  sessionIssues,
  updateSessionIssue,
  processServerError
})
{

  // Define the kinds of filters that will be available to the user
  const FILTER = {
    TYPE: {
      SEVERITY: 'SEVERITY',
      CONTENT_TYPE: 'CONTENT_TYPE',
      RESOLUTION: 'RESOLUTION',
      MODULE: 'MODULE',
      PUBLISHED: 'PUBLISHED',
    },
    ALL: 'ALL',
    ISSUE: 'ISSUE',
    POTENTIAL: 'POTENTIAL',
    SUGGESTION: 'SUGGESTION',
    PAGE: 'PAGE',
    ASSIGNMENT: 'ASSIGNMENT',
    ANNOUNCEMENT: 'ANNOUNCEMENT',
    DISCUSSION_TOPIC: 'DISCUSSION_TOPIC',
    DISCUSSION_FORUM: 'DISCUSSION_FORUM',
    FILE: 'FILE',
    QUIZ: 'QUIZ',
    SYLLABUS: 'SYLLABUS',
    MODULE: 'MODULE',
    FILE_OBJECT: 'FILE_OBJECT',
    ACTIVE: 'ACTIVE',
    FIXED: 'FIXED',
    RESOLVED: 'RESOLVED',
    FIXEDANDRESOLVED: 'FIXEDANDRESOLVED', // Doesn't appear in any dropdowns, but is used in the code
    PUBLISHED: 'PUBLISHED',
    UNPUBLISHED: 'UNPUBLISHED',
  }

  const defaultFilters = {
    [FILTER.TYPE.SEVERITY]: FILTER.ALL,
    [FILTER.TYPE.PUBLISHED]: FILTER.PUBLISHED,
    [FILTER.TYPE.CONTENT_TYPE]: FILTER.ALL,
    [FILTER.TYPE.RESOLUTION]: FILTER.ACTIVE,
    [FILTER.TYPE.MODULE]: FILTER.ALL,
  }

  const defaultNoFilters = {
    [FILTER.TYPE.SEVERITY]: FILTER.ALL,
    [FILTER.TYPE.PUBLISHED]: FILTER.ALL,
    [FILTER.TYPE.CONTENT_TYPE]: FILTER.ALL,
    [FILTER.TYPE.RESOLUTION]: FILTER.ALL,
    [FILTER.TYPE.MODULE]: FILTER.ALL,
  }

  const WIDGET_STATE = {
    LOADING: 0,
    FIXIT: 1,
    LEARN: 2,
    LIST: 3,
    NO_RESULTS: 4,
  }

  const FILE_TYPES = [
    'pdf',
    'doc',
    'ppt',
    'xls',
  ]

  const headers = [
    { id: "name", text: t('fix.label.file_name') },
    { id: "type", text: t('fix.label.file_type')},
    { id: "date", text: t('fix.label.file_updated'), alignText: 'center', format: Text.getReadableDateTime },
    { id: "size", text: t('fix.label.file_size'), alignText: 'center', format: Text.getReadableFileSize },
    { id: "resolved", text: t('report.header.resolved'), alignText: 'center' },
  ]

  const [tableSettings, setTableSettings] = useState({
      sortBy: 'name',
      ascending: false,
      pageNum: 0,
  })

  const handleTableSettings = (setting) => {
    setTableSettings(Object.assign({}, tableSettings, setting))
  }

  const [rows, setRows] = useState([])
  const [activeIssue, setActiveIssue] = useState(null)
  const [tempActiveIssue, setTempActiveIssue] = useState(null)
  const [activeContentItem, setActiveContentItem] = useState(null)
  const [contentItemsBeingScanned, setContentItemsBeingScanned] = useState([])
  const [isErrorFoundInContent, setIsErrorFoundInContent] = useState(false)
  const [searchTerm, setSearchTerm] = useState('')
  const [activeFilters, setActiveFilters] = useState(defaultNoFilters)
  const [unfilteredIssues, setUnfilteredIssues] = useState([])
  const [filteredIssues, setFilteredIssues] = useState([])
  const [widgetState, setWidgetState] = useState(WIDGET_STATE.LOADING)
  const [liveUpdateToggle, setLiveUpdateToggle] = useState(true)

  const formatFileData = (fileData) => {
    // All files should be considered "Potential Issues" since they need to be reviewed and are
    // not included in the PHPAlly or IBM Equal Access scan.

    let fileId = "file-" + fileData.id

    let issueResolution = FILTER.ACTIVE
    if(fileData.reviewed) {
      issueResolution = FILTER.RESOLVED
    }

    let formLabel = t(`form.file.title`)

    let fileTypeLabel = t(`label.mime.unknown`)
    
    // Guarantee that the keywords include the word "file" in each language
    let keywords = [ fileData.fileName.toLowerCase(), fileTypeLabel.toLowerCase(), formLabel.toLowerCase() ]
    
    // Keywords should include the file type ('MS Word', 'PDF', etc.)
    if(FILE_TYPES.includes(fileData.fileType)) {
      fileTypeLabel = t(`label.mime.${fileData.fileType}`)
      keywords.push[fileTypeLabel.toLowerCase()]
    }

    keywords = keywords.join(' ')

// Canvas File Item Data:
  // active: true
  // downloadUrl: "https://canvas.dev.cdl.ucf.edu/files/13041/download?download_frd=1&verifier=V4WBmWDBfN64x09tieoEqjfKWQWaK0HKXBI0CF54"
  // fileName: "1742314259_587__UCF-_Getting_Started_with_Serverless.pdf"
  // fileSize: "1923148"
  // fileType: "pdf"
  // hidden: false
  // id: 7
  // lmsFileId: "13041"
  // lmsUrl: "https://canvas.dev.cdl.ucf.edu/courses/383/files?preview=13041"
  // reviewed: null
  // status: true
  // updated: "2025-03-18T16:11:00+00:00"

// Canvas Section Item Data:
  // content_id: 13041
  // html_url: "https://canvas.dev.cdl.ucf.edu/courses/383/modules/items/4020"
  // id: 4020
  // indent: 0
  // module_id: 583
  // position: 1
  // published: true
  // quiz_lti: false
  // title: "UCF- Getting Started with Serverless.pdf"
  // type: "File"
  // url: "https://canvas.dev.cdl.ucf.edu/api/v1/courses/383/files/13041"

    let fileSectionIds = []

    if(sections && sections.length > 0) {
      sections.forEach((section) => {
        let tempSectionId = section.id
        section.items.forEach((item) => {
          if(item.content_id && item.content_id.toString() === fileData.lmsFileId.toString()) {
            fileSectionIds.push(tempSectionId.toString())
          }
        })
      })
    }

    let currentState = settings.ISSUE_STATE.UNCHANGED
    if(sessionIssues && sessionIssues[fileId]) {
      currentState = sessionIssues[fileId]
    }

    return {
      fileData: Object.assign({}, fileData),
      id: fileId,
      severity: FILTER.POTENTIAL,
      status: issueResolution,
      published: true,
      sectionIds: fileSectionIds,
      keywords: keywords,
      scanRuleId: 'verify_file_accessibility',
      formLabel: formLabel,
      contentId: fileData.lmsFileId,
      contentType: FILTER.FILE_OBJECT,
      contentTitle: fileData.fileName,
      contentUrl: fileData.lmsUrl,
      currentState: currentState,
    }
  }

  const addItemToBeingScanned = (contentItemId) => {
    let tempContentItems = contentItemsBeingScanned
    if(!tempContentItems.includes(contentItemId)) {
      tempContentItems.push(contentItemId)
      setContentItemsBeingScanned(tempContentItems)
    }
  }

  const removeItemFromBeingScanned = (contentItemId) => {
    let tempContentItems = contentItemsBeingScanned
    if(tempContentItems.includes(contentItemId)) {
      tempContentItems = tempContentItems.filter((item) => item !== contentItemId)
      setContentItemsBeingScanned(tempContentItems)
    }
  }

  // When the filters or search term changes, update the filtered issues list
  useEffect(() => {

    let tempFilteredContent = getFilteredContent(unfilteredIssues)
    let tempTableSettings = Object.assign({}, tableSettings)

    if(tempFilteredContent.length !== filteredIssues.length) {
      tempTableSettings.pageNum = 0
      handleTableSettings({ pageNum: 0 })
    }

    setFilteredIssues(tempFilteredContent)
    setWidgetState(WIDGET_STATE.LIST)

  }, [activeFilters, searchTerm])

  const getContent = () => {
    if (filteredIssues.length === 0) {
      return []
    }

    let tempRows = []
    filteredIssues.forEach((tempFile) => {
      tempRows.push({
        id: tempFile.id,
        name: tempFile.contentTitle,
        type: tempFile.fileData.fileType ? t(`label.mime.${tempFile.fileData.fileType}`) : t('label.mime.unknown'),
        date: tempFile.fileData.updated,
        size: (tempFile.fileData.fileSize) ? parseInt(tempFile.fileData.fileSize) : t('label.unknown'),
        resolved: (tempFile.status !== FILTER.ACTIVE) ? t('label.yes') : t('label.no'),
      })
    })

    const { sortBy, ascending } = tableSettings

    tempRows.sort((a, b) => {
      if (isNaN(a[sortBy]) || isNaN(b[sortBy])) {
        return (a[sortBy].toLowerCase() > b[sortBy].toLowerCase()) ? -1 : 1
      }
      else {
        return (Number(a[sortBy]) < Number(b[sortBy])) ? -1 : 1
      }
    })

    if (!ascending) {
      tempRows.reverse()
    }

    return tempRows
  }

  useEffect(() => {
    setRows(getContent())
  }, [tableSettings, filteredIssues])

  // The report object is updated whenever a scan or rescan is completed. At this point, the list of issues
  // needs to be rebuilt and the activeIssue may need to be updated. For instance, if an issue is marked as
  // unreviewed then it will be deleted during the rescan and a new issue with a new id will take its place.
  useEffect(() => {
    let tempUnfilteredIssues = []
    let tempRows = []

    let tempFiles = Object.assign({}, report.files)
    for (const [key, value] of Object.entries(tempFiles)) {
      let tempFile = formatFileData(value)
      tempUnfilteredIssues.push(tempFile)
      tempRows.push({
        id: tempFile.id,
        name: tempFile.contentTitle,
        type: tempFile.fileData.fileType ? t(`label.mime.${tempFile.fileData.fileType}`) : t('label.mime.unknown'),
        date: (new Date(tempFile.fileData.updated)).toLocaleDateString(),
        size: (tempFile.fileData.fileSize) ? `${(tempFile.fileData.fileSize / 1024).toFixed(2)} KB` : t('label.unknown'),
        resolved: (tempFile.status !== FILTER.ACTIVE) ? t('label.yes') : t('label.no'),
      })
    }

    tempUnfilteredIssues.sort((a, b) => {
      return (a.formLabel.toLowerCase() < b.formLabel.toLowerCase()) ? -1 : 1
    })

    tempRows.sort((a, b) => {
      return (a.name.toLowerCase() < b.name.toLowerCase()) ? -1 : 1
    })

    setRows(tempRows)

    // Every time the list changes, we need to reload the activeContentItem. This will come from the
    // cache (contentItemCache) or from the database, if not in the cache.
    setActiveContentItem(null)

    // The filtered list should ALWAYS include the current activeIssue, even if it no longer matches
    // the filters. For instance, if I'm only looking through "Unreviewed" issues, and I click on the
    // "Mark as Reviewed" button, that newly-reviewed issue should be available to stay on screen.
    let holdoverActiveIssue = null

    // If there is an activeIssue, we need to connect it to something in the new list of issues.
    if(activeIssue) {  
      // Quick check: is the old activeIssue still in the list?
      tempUnfilteredIssues.forEach((issue) => {
        if(issue.id === activeIssue.id) {
          holdoverActiveIssue = issue
        }
      })

      // If not, we need to do a more thorough check.
      if(holdoverActiveIssue === null) {
        if(activeIssue.contentType === FILTER.FILE_OBJECT) {
          tempUnfilteredIssues.forEach((issue) => {
            if(issue.contentId === activeIssue.contentId) {
              holdoverActiveIssue = issue
            }
          })
        }
        else {
          tempUnfilteredIssues.forEach((issue) => {
            if(issue.scanRuleId === activeIssue.scanRuleId &&
                issue.contentId === activeIssue.contentId &&
                issue.issueData.xpath === activeIssue.issueData.xpath) {
              updateActiveSessionIssue(issue.id, null, issue.issueData.contentItemId)
              holdoverActiveIssue = issue
            }
          })
        }
      }

      if(holdoverActiveIssue === null) {
        setWidgetState(WIDGET_STATE.LIST)
      }
    }

    setUnfilteredIssues(tempUnfilteredIssues)
    let tempFilteredContent = getFilteredContent(tempUnfilteredIssues, holdoverActiveIssue?.id || null)

    setFilteredIssues(tempFilteredContent)
    setActiveIssue(holdoverActiveIssue)
  }, [report])


  // When a new activeIssue is set, get the content for that issue
  useEffect(() => {
    if(activeIssue === null) {
      setActiveContentItem(null)
      setTempActiveIssue(null)
      setWidgetState(WIDGET_STATE.LIST)
      return
    }
  
    setWidgetState(WIDGET_STATE.FIXIT)
    const activeIssueClone = JSON.parse(JSON.stringify(activeIssue))

    if(activeIssue.contentType === FILTER.FILE_OBJECT) {
      setTempActiveIssue(activeIssueClone)
      setActiveContentItem(null)
      setIsErrorFoundInContent(true)
      return
    }

    activeIssueClone.issueData.initialHtml = Html.getIssueHtml(activeIssueClone.issueData)
    setTempActiveIssue(activeIssueClone)

    // If we've already downloaded the content for this issue, use that
    const contentItemId = activeIssue.issueData.contentItemId
    if(contentItemCache[contentItemId]) {
      setActiveContentItem(contentItemCache[contentItemId])
      return
    }

    // Otherwise, clear the old content and download the content for this issue
    setActiveContentItem(null)
    loadContentItemByIssue(activeIssue)

  }, [activeIssue])

  useEffect(() => {
    let tempContentItem = null
    if(activeIssue?.issueData?.contentItemId) {
      tempContentItem = contentItemCache[activeIssue.issueData.contentItemId] || null
    }
    setActiveContentItem(tempContentItem)
  }, [contentItemCache])

  const getFilteredContent = (allIssues, includedIssueId = null) => {
    let filteredList = []
    const tempFilters = Object.assign({}, activeFilters)

    // PHPAlly Issues have a 'type' of 'error' or 'suggestion'
    // // Check for easy issues filter
    // if (tempFilters.easyIssues && tempFilters.issueTitles.length == 0) {
    //   tempFilters.issueTitles = easyRules
    // }
    // Loop through the issues

    for (const issue of allIssues) {

      // When we have just saved or resolved an issue, we want to keep that one in the list
      // even if it doesn't match the filters. This is used to show the user that their changes
      // were successful.
      if(includedIssueId && issue.id === includedIssueId) {
        filteredList.push(issue)
        continue
      }

      // Do not include this issue if it doesn't match the severity filter
      if (tempFilters[FILTER.TYPE.SEVERITY] !== FILTER.ALL && tempFilters[FILTER.TYPE.SEVERITY] !== issue.severity) {
        continue
      }

      // Do not include this issue if it doesn't match the content type filter
      let tempContentType = issue.contentType
      let tempStatus = issue.status === FILTER.FIXEDANDRESOLVED ? FILTER.FIXED : issue.status
      if (tempContentType === FILTER.FILE_OBJECT) {
        // When the user selects "Files", show both "File" issues as well as external File objects
        tempContentType = FILTER.FILE
      }
      if (tempFilters[FILTER.TYPE.CONTENT_TYPE] !== FILTER.ALL && tempFilters[FILTER.TYPE.CONTENT_TYPE] !== tempContentType) {
        continue
      }

      // Do not include this issue if it doesn't match the status filter
      if (tempFilters[FILTER.TYPE.RESOLUTION] !== FILTER.ALL && tempFilters[FILTER.TYPE.RESOLUTION] !== tempStatus) {
        continue
      }

      // Do not include this issue if it doesn't match the module filter
      if (tempFilters[FILTER.TYPE.MODULE] !== FILTER.ALL && !issue.sectionIds.includes(tempFilters[FILTER.TYPE.MODULE].toString())) {
        continue
      }

      // Do not include this issue if it doesn't match the published filter
      if (tempFilters[FILTER.TYPE.PUBLISHED] !== FILTER.ALL && (tempFilters[FILTER.TYPE.PUBLISHED] === FILTER.PUBLISHED) !== issue.published) {
        continue
      }

      // Do not include this issue if it doesn't contain the search term/s
      if (searchTerm !== '') {
        const searchTerms = searchTerm.toLowerCase().split(' ')
        let containsAllTerms = true
        if (Array.isArray(searchTerms)) {
          for (let term of searchTerms) {
            if (!issue.keywords.includes(term)) {
              containsAllTerms = false
            }
          }
        }
        if (!containsAllTerms) {
          continue
        }
      }

      // Check to see if the user ONLY wants to see issues from published content
      if(settings?.user?.roles?.view_only_published && issue.issueData) {
        let tempContentItem = getContentById(issue.issueData.contentItemId)
        if(tempContentItem && tempContentItem.published === false) {
          continue
        }
      }

      // If the issue passes all filters, add it to the list!
      filteredList.push(issue)
    }

    filteredList.sort((a, b) => {
      return (a.formLabel.toLowerCase() < b.formLabel.toLowerCase()) ? -1 : 1
    })

    return filteredList
  }

  const loadContentItemByIssue = (issue) => {
    let contentItemId = issue?.issueData?.contentItemId || null
    if(contentItemId) {
      addItemToBeingScanned(contentItemId)
      let api = new Api(settings)
      api.getIssueContent(issue.id)
      .then((response) => {
        return response.json()
      }).then((data) => {
        if(data?.data?.contentItem) {
          const newContentItem = data.data.contentItem
          addContentItemToCache(newContentItem)
        }
        removeItemFromBeingScanned(contentItemId)
      })
    }
  }


  // All local information must be updated to match the new issue state:
  // - activeIssue
  // - unfilteredIssues
  // - filteredIssues
  // This does NOT change the report object, which updates when the issue's data changes.
  const updateActiveSessionIssue = (issueId, state = null, contentItemId = null) => {
    
    if(state === null) {
      state = settings.ISSUE_STATE.UNCHANGED
    }

    // This updates the counter for the daily progress
    updateSessionIssue(issueId, state, contentItemId)

    // Only update the whole list if the issue is saved, resolved, or marked as unresolved.
    if(state === settings.ISSUE_STATE.SAVED
      || state === settings.ISSUE_STATE.RESOLVED
      || state === settings.ISSUE_STATE.UNCHANGED) {

        let tempUnfilteredIssues = unfilteredIssues.map((issue) => {
          if(issue.id === issueId) {
            let tempIssue = Object.assign({}, issue)
            tempIssue.currentState = state
            return tempIssue
          }
          return issue
        })
        setUnfilteredIssues(tempUnfilteredIssues)
        setFilteredIssues(getFilteredContent(tempUnfilteredIssues, activeIssue?.id || null))
    }

    // This updates the active issue to the current state, which allows the proper UI to show
    // (like "Processing..." which disables the buttons).
    if(activeIssue) {
      let tempIssue = activeIssue
      if(tempIssue.id === issueId) {
        tempIssue.currentState = state
        setActiveIssue(tempIssue)
      }
    }
  }

  const updateFile = (tempFile) => {
    const tempReport = Object.assign({}, report)

    // Occasionally, the report will send back a list of files in an object instead of an array.
    // It would be nice to use tempReport.files.map, but that doesn't work with objects.
    for (const [key, value] of Object.entries(tempReport.files)) {
      if (key.toString() === tempFile.id.toString()) {
        if(activeIssue?.fileData?.id === tempFile.id) {
          const formattedFile = formatFileData(tempFile)
          setActiveIssue(formattedFile)
        }
        tempReport.files[key] = tempFile
      }
    }
    processNewReport(tempReport)
  }

  const getNewFullPageHtml = (content, issue) => {
    if(!content?.body || !issue) {
      return
    }

    // Create the full HTML string for the new version of the content item.
    const parser = new DOMParser()
    const tempDoc = parser.parseFromString(content.body, 'text/html')

    let errorElement = Html.findElementWithIssue(tempDoc, issue)
      
    if(!errorElement) {
      console.warn("Could not find error element when attempting to save...")
      return
    }
    const newElement = Html.toElement(issue?.newHtml)
    
    // Replace or remove the error element
    if(newElement) {
      errorElement.replaceWith(newElement)  
    } else {
      errorElement.remove()
    }

    return tempDoc.body.innerHTML
  }

  const handleIssueSave = (issue, markAsReviewed = false) => {

    if(!activeContentItem || !activeContentItem?.body || !issue) {
      return
    }

    updateActiveSessionIssue(issue.id, settings.ISSUE_STATE.SAVING)
    addItemToBeingScanned(issue.contentItemId)

    const specificClassName = `udoit-ignore-${issue.scanRuleId.replaceAll("_", "-")}`
    if (markAsReviewed) {
      if (issue.status === 1) {
        issue.status = 3
        issue.newHtml = Html.toString(Html.addClass(issue.newHtml, specificClassName))
      } else if (issue.status === 0) {
        issue.status = 2
        issue.newHtml = Html.toString(Html.addClass(issue.sourceHtml, specificClassName))
      }
    } else {
      if (issue.status === 3) {
        issue.status = 1
        issue.newHtml = Html.toString(Html.removeClass(issue.newHtml, specificClassName))
      } else if (issue.status === 2) {
        issue.status = 0
        issue.newHtml = Html.toString(Html.removeClass(issue.sourceHtml, specificClassName))
      }
    }

    let fullPageHtml = getNewFullPageHtml(activeContentItem, issue)
    let fullPageDoc = new DOMParser().parseFromString(fullPageHtml, 'text/html')
    let newElement = Html.findElementWithError(fullPageDoc, issue?.newHtml)
    let newXpath = Html.findXpathFromElement(newElement)
    if(newXpath) {
      issue.xpath = newXpath
    }
    else {
      issue.xpath = ""
    }
    activeContentItem.body = fullPageHtml

    // Save the updated issue using the LMS API
    let api = new Api(settings)
    try {
      api.saveIssue(issue, fullPageHtml, markAsReviewed)
      .then((responseStr) => {
        // Check for HTTP errors before parsing JSON
          if (!responseStr.ok) {
            processServerError(responseStr)
            updateActiveSessionIssue(issue.id, settings.ISSUE_STATE.ERROR)
            removeItemFromBeingScanned(issue.contentItemId)
            return null
          }
          return responseStr.json()
      })
      .then((response) => {

        // If the save falied, show the relevant error message
        if (response.data.failed) {
          updateActiveSessionIssue(issue.id, settings.ISSUE_STATE.ERROR)
          removeItemFromBeingScanned(issue.contentItemId)
          response.messages.forEach((msg) => addMessage(msg))
            
          if (Array.isArray(response.data.issues)) {
            response.data.issues.forEach((issue) => {
              addMessage({
                severity: 'error',
                message: t(`form.error.${issue.ruleId}`)
              })
            })
          }

          if (Array.isArray(response.data.errors)) {
            response.data.errors.forEach((error) => {
              addMessage({
                severity: 'error',
                message: error
              })
            })
          }
        }
        else {
          
          // If the save was successful, show the success message
          response.messages.forEach((msg) => addMessage(msg))
          
          if (response.data.issue) {
            // Update the report object by rescanning the content
            const newIssue = Object.assign({}, issue, response.data.issue)
            // setActiveIssue(formattedData)
            updateActiveSessionIssue(newIssue.id, settings.ISSUE_STATE.SAVED)

            api.scanContent(newIssue.contentItemId)
              .then((responseStr) => responseStr.json())
              .then((res) => { 
                const tempReport = Object.assign({}, res?.data)
                processNewReport(tempReport)
                removeItemFromBeingScanned(newIssue.contentItemId)
              })
          }
          else {
            // setActiveIssue(formatIssueData(issue))
            updateActiveSessionIssue(issue.id, settings.ISSUE_STATE.SAVED)
            removeItemFromBeingScanned(issue.contentItemId)
          }
        }
      })
    } catch (error) {
      console.error(error)
      updateActiveSessionIssue(issue.id, settings.ISSUE_STATE.ERROR)
    }
  }

  /**
   * handleFileUpload is called when a new file has already been selected by the user
   * and is ready to be uploaded to the server and verified.
   */
  const handleFileUpload = (newFileData) => {

    const tempFile = Object.assign({}, activeIssue.fileData)

    updateActiveSessionIssue("file-" + tempFile.id, settings.ISSUE_STATE.SAVING)

    try {
      let api = new Api(settings)
      api.postFile(tempFile, newFileData)
        .then((responsStr) => responsStr.json())
        .then((response) => {
          const updatedFileData = { ...tempFile, ...response.data.file }

          // Set messages 
          response.messages.forEach((msg) => addMessage(msg))

          // Update the local report and activeIssue
          updateActiveSessionIssue("file-" + tempFile.id, settings.ISSUE_STATE.SAVED)
          updateFile(updatedFileData)
        })
    } catch (error) {
      console.error(error)
      updateActiveSessionIssue("file-" + tempFile.id, settings.ISSUE_STATE.ERROR)
    }
  }

  const handleFileResolve = (fileData) => {
    updateActiveSessionIssue("file-" + fileData.id, settings.ISSUE_STATE.RESOLVING)
    
    let tempFile = Object.assign({}, fileData)
    tempFile.reviewed = !(tempFile.reviewed) 

    try {
      let api = new Api(settings)
      api.reviewFile(tempFile)
        .then((responseStr) => responseStr.json())
        .then((response) => {
          const reviewed = (response?.data?.file && ('reviewed' in response.data.file)) ? response.data.file.reviewed : false
          const newFileData = { ...tempFile }
          newFileData.reviewed = reviewed

          // Set messages
          response.messages.forEach((msg) => addMessage(msg))

          // Update the local report and activeIssue
          if(reviewed) {
            updateActiveSessionIssue("file-" + fileData.id, settings.ISSUE_STATE.RESOLVED)
          }
          else {
            updateActiveSessionIssue("file-" + fileData.id, settings.ISSUE_STATE.UNCHANGED)
          }
          updateFile(newFileData)
        })
    } catch (error) {
      console.warn(error)
      updateActiveSessionIssue("file-" + fileData.id, settings.ISSUE_STATE.ERROR)
    }
  }

  const updateActiveFilters = (filter, value) => {
    setActiveFilters(Object.assign({}, activeFilters, {[filter]: value}))
  }

  const nextIssue = (previous = false) => {
    if (!activeIssue || filteredIssues.length < 2) { return }
    let activeIndex = filteredIssues.findIndex((issue) => issue.id === activeIssue.id)

    if(activeIndex === -1) { return }

    // If we've reached the first or last issue, loop around
    let newIndex = activeIndex + (previous ? -1 : 1)
    if (newIndex < 0) {
      newIndex = filteredIssues.length - 1
    }
    else if (newIndex >= filteredIssues.length) {
      newIndex = 0
    }
    setActiveIssue(filteredIssues[newIndex])
  }

  const toggleListView = () => {
    if (widgetState === WIDGET_STATE.LIST) {
      if(activeIssue) {
        setWidgetState(WIDGET_STATE.FIXIT)
      }
      else {
        setWidgetState(WIDGET_STATE.NO_RESULTS)
      }
    }
    else {
      setWidgetState(WIDGET_STATE.LIST)
      setActiveIssue(null)
      setActiveContentItem(null)
    }
  }

  const getContentById = (contentId) => {
    if(!report.contentItems[contentId]) {
      return null
    }
    return report.contentItems[contentId]
  }

  const triggerLiveUpdate = () => {
    setLiveUpdateToggle(!liveUpdateToggle)
  }

  return (
    <>
      { widgetState === WIDGET_STATE.LOADING ? (
        <></>
      ) : widgetState === WIDGET_STATE.LIST ? (
        <>
          <FixIssuesFilters
            t={t}
            settings={settings.FILTER ? settings : Object.assign({}, settings, { FILTER })}

            activeFilters={activeFilters}
            handleSearchTerm={setSearchTerm}
            searchTerm={searchTerm}
            sections={sections}
            updateActiveFilters={updateActiveFilters}
          />
          <SortableTable
            t={t}
            headers={headers}
            rows={rows}
            tableSettings={tableSettings}
            handleTableSettings={handleTableSettings}
          />
        </>
      ) : (
        <div className="flex-row gap-2 w-100 h-100">
          <section className='ufixit-widget-container'>
            <button onClick={toggleListView} className="btn btn-link btn-icon-left btn-small mb-2">
              <LeftArrowIcon className="icon-sm link-color" />{t('fix.button.list')}
            </button>
            { tempActiveIssue ? (  
                <UfixitWidget
                  t={t}
                  settings={settings.FILTER ? settings : Object.assign({}, settings, { FILTER })}
                  activeContentItem={activeContentItem}
                  addMessage={addMessage}
                  handleFileResolve={handleFileResolve}
                  handleFileUpload={handleFileUpload}
                  handleIssueSave={handleIssueSave}
                  isContentLoading={contentItemsBeingScanned.includes(tempActiveIssue?.issueData?.contentItemId)}
                  isErrorFoundInContent={isErrorFoundInContent}
                  sessionIssues={sessionIssues}
                  setTempActiveIssue={setTempActiveIssue}
                  severity={tempActiveIssue.severity}
                  tempActiveIssue={tempActiveIssue}
                  triggerLiveUpdate={triggerLiveUpdate}
                />
            ) : ''}
          </section>
          <section className="ufixit-content-container">
            {filteredIssues.length > 0 && (
              <FixIssuesContentPreview
                t={t}
                settings={settings.FILTER ? settings : Object.assign({}, settings, { FILTER })}

                activeContentItem={activeContentItem}
                activeIssue={tempActiveIssue}
                contentItemsBeingScanned={contentItemsBeingScanned}
                liveUpdateToggle={liveUpdateToggle}
                setIsErrorFoundInContent={setIsErrorFoundInContent}
              />
            )}
            <div className="flex-row justify-content-end gap-2 mt-3">
              <button
                className={`btn btn-small btn-link btn-icon-left ${filteredIssues.length < 2 ? 'disabled' : ''}`}
                onClick={() => nextIssue(true)}
                tabIndex="0">
                <LeftArrowIcon className={`icon-sm ` + (filteredIssues.length < 2 ? 'gray' : 'link-color')} />
                <div className="flex-column justify-content-center">{t('fix.button.previous')}</div>
              </button>

              <button
                className={`btn btn-small btn-link btn-icon-right ${filteredIssues.length < 2 ? 'disabled' : ''}`}
                onClick={() => nextIssue()}
                tabIndex="0">
                <div className="flex-column justify-content-center">{t('fix.button.next')}</div>
                <RightArrowIcon className={`icon-sm ` + (filteredIssues.length < 2 ? 'gray' : 'link-color')} />
              </button>
            </div>
          </section>
        </div>
      )}
    </>
  )
}