import React, { useState, useEffect } from 'react'
import ReviewFilesFilters from './Widgets/ReviewFilesFilters'
import SortableTable from './Widgets/SortableTable'
import FileFixitWidget from './Widgets/FileFixitWidget'
import FileReviewPreview from './Widgets/FileReviewPreview'
import FileTypeIcon from './Icons/FileTypeIcon'
import LeftArrowIcon from './Icons/LeftArrowIcon'
import RightArrowIcon from './Icons/RightArrowIcon'
import SeverityPotentialIcon from './Icons/SeverityPotentialIcon'
import FixedIcon from './Icons/FixedIcon'
import * as Text from '../Services/Text'
import Api from '../Services/Api'

import './FixIssuesPage.css'
import './ReviewFilesPage.css'


/** The data for this component can be a bit confusing, so here's a breakdown:
  * - report: The main report object is generated by the scanner.
  * --- report.issues: All of the issues in a format that mirrors the database. Saving a loading is done with this.
  * --- report.files: All of the files in a format that mirrors the database. Saving a loading is done with this.
  * --- report.contentItems: All of the content items in the course. This is used to store the content for each issue.
  * 
  * After the data is brought in through the API, it is formatted in the formatIssueData and formatFileData functions
  * and stored in a list that can be filtered.
  * - unfilteredIssues: A list of all the issues in the course, formatted for the front end.
  * - filteredIssues: A list of the issues that match the current filters and search term.
  * - activeIssue: The issue that is currently being viewed and edited, including non-database attributes
  * --- activeIssue.issueData: The issue as it is stored in the database. Matches report.issues for the issue.
  * --- activeIssue.fileData: The file as it is stored in the database. Matches report.files for the file.
**/

export default function ReviewFilesPage({
  t,
  settings,
  
  report,
  sections,
  processNewReport,
  addMessage,
  sessionIssues,
  updateSessionIssue,
})
{

  // Define the kinds of filters that will be available to the user
  const FILTER = settings.FILE_FILTER

  const defaultFilters = {
    [FILTER.TYPE.UTILIZATION]: FILTER.USED,
    [FILTER.TYPE.FILE_TYPE]: FILTER.ALL,
    [FILTER.TYPE.RESOLUTION]: FILTER.UNREVIEWED,
    [FILTER.TYPE.MODULE]: FILTER.ALL,
  }

  const WIDGET_STATE = settings.WIDGET_STATE

  const dialogId = "file-dialog"

  const headers = [
    { id: "name", text: t('fix.label.file_name') },
    { id: "type", text: t('fix.label.file_type')},
    { id: "references", text: t('fix.label.references')},
    { id: "date", text: t('fix.label.file_updated')},
    { id: "size", text: t('fix.label.file_size')},
    { id: "status", text: t('fix.label.status')},
  ]

  const [tableSettings, setTableSettings] = useState({
      sortBy: 'name',
      ascending: false,
      pageNum: 0,
  })

  const handleTableSettings = (setting) => {
    setTableSettings(Object.assign({}, tableSettings, setting))
  }

  const [rows, setRows] = useState([])
  const [activeIssue, setActiveIssue] = useState(null)
  const [tempActiveIssue, setTempActiveIssue] = useState(null)
  const [searchTerm, setSearchTerm] = useState('')
  const [activeFilters, setActiveFilters] = useState(defaultFilters)
  const [unfilteredFiles, setUnfilteredFiles] = useState([])
  const [filteredFiles, setFilteredFiles] = useState([])
  const [widgetState, setWidgetState] = useState(WIDGET_STATE.LOADING)

  const formatFileData = (fileData) => {

    let fileId = "file-" + fileData.id

    let issueResolution = (fileData.reviewed ? FILTER.REVIEWED : FILTER.UNREVIEWED)

    let formLabel = t(`form.file.title`)

    let fileType = FILTER.FILE_UNKNOWN
    let fileTypeLabel = t(`label.mime.unknown`)
    
    // Guarantee that the keywords include the word "file" in each language
    let keywords = [ fileData.fileName.toLowerCase() ]
    
    // Keywords should include the file type ('MS Word', 'PDF', etc.)
    if(settings.FILE_TYPES.includes(fileData.fileType)) {
      fileType = settings.FILE_TYPE_MAP[fileData.fileType]
      fileTypeLabel = t(`label.mime.${fileData.fileType}`)
      keywords.push[fileTypeLabel.toLowerCase()]
    }

    keywords = keywords.join(' ')

    let currentState = settings.ISSUE_STATE.UNCHANGED
    if(sessionIssues && sessionIssues[fileId]) {
      currentState = sessionIssues[fileId]
    }

    return {
      fileData: Object.assign({}, fileData),
      id: fileId,
      severity: FILTER.POTENTIAL,
      status: issueResolution,
      published: true,
      fileType: fileType,
      sectionIds: fileData.sections || [],
      keywords: keywords,
      scanRuleId: 'verify_file_accessibility',
      formLabel: formLabel,
      contentId: fileData.lmsFileId,
      contentType: FILTER.FILE_OBJECT,
      contentTitle: fileData.fileName,
      contentUrl: fileData.lmsUrl,
      currentState: currentState,
    }
  }

  // When the filters or search term changes, update the filtered issues list
  useEffect(() => {

    let tempFilteredFiles = getFilteredContent(unfilteredFiles)
    let tempTableSettings = Object.assign({}, tableSettings)

    if(tempFilteredFiles.length !== filteredFiles.length) {
      tempTableSettings.pageNum = 0
      handleTableSettings({ pageNum: 0 })
    }

    setFilteredFiles(tempFilteredFiles)
    setWidgetState(WIDGET_STATE.LIST)

  }, [activeFilters, searchTerm])

  const getContent = () => {
    if (filteredFiles.length === 0) {
      return []
    }

    let tempRows = []
    filteredFiles.forEach((tempFile) => {
      tempRows.push({
        id: tempFile.id,
        name: tempFile.contentTitle ? { value: tempFile.contentTitle, display: getFileNameDisplay(tempFile)} : t('label.unknown'),
        type: tempFile.fileData.fileType ? { value: tempFile.fileData.fileType, display: getFileTypeDisplay(tempFile.fileData.fileType)}: t('label.mime.unknown'),
        date: tempFile.fileData.updated ? { value: tempFile.fileData.updated, display: Text.getReadableDateTime(tempFile.fileData.updated)} : t('label.unknown'),
        size: tempFile.fileData.fileSize ? { value: parseInt(tempFile.fileData.fileSize), display: Text.getReadableFileSize(tempFile.fileData.fileSize) } : t('label.unknown'),
        references: (tempFile.fileData?.references.length) || 0,
        status: tempFile.status ? { value: t('fix.label.status.' + (tempFile.status.toLowerCase())), display: getFileStatusDisplay(tempFile.status)} : '',
        onClick: () => { jumpToFile(tempFile.id) },
        onKeyDown: (e) => {
          if (e.key === 'Enter' || e.key === ' ') {
            jumpToFile(tempFile.id)
          }
        }
      })
    })

    const { sortBy, ascending } = tableSettings

    tempRows.sort((a, b) => {
      let aSort = a[sortBy]
      if(typeof aSort === 'object' && aSort.value) {
        aSort = aSort.value
      }
      
      let bSort = b[sortBy]
      if(typeof bSort === 'object' && bSort.value) {
        bSort = bSort.value
      }

      if (isNaN(aSort) || isNaN(bSort)) {
        return (aSort.toLowerCase() > bSort.toLowerCase()) ? -1 : 1
      }
      else {
        return (Number(aSort) < Number(bSort)) ? -1 : 1
      }
    })

    if (!ascending) {
      tempRows.reverse()
    }

    return tempRows
  }

  useEffect(() => {
    setRows(getContent())
  }, [tableSettings, filteredFiles])

  // The report object is updated whenever a scan or rescan is completed. At this point, the list of issues
  // needs to be rebuilt and the activeIssue may need to be updated. For instance, if an issue is marked as
  // unreviewed then it will be deleted during the rescan and a new issue with a new id will take its place.
  useEffect(() => {
    let tempUnfilteredIssues = []

    let tempFiles = Object.assign({}, report.files)
    for (const [key, value] of Object.entries(tempFiles)) {
      let tempFile = formatFileData(value)
      tempUnfilteredIssues.push(tempFile)
    }

    tempUnfilteredIssues.sort((a, b) => {
      return (a.formLabel.toLowerCase() < b.formLabel.toLowerCase()) ? -1 : 1
    })

    // The filtered list should ALWAYS include the current activeIssue, even if it no longer matches
    // the filters. For instance, if I'm only looking through "Unreviewed" issues, and I click on the
    // "Mark as Reviewed" button, that newly-reviewed issue should be available to stay on screen.
    let holdoverActiveIssue = null

    // If there is an activeIssue, we need to connect it to something in the new list of issues.
    if(activeIssue) {  
      // Quick check: is the old activeIssue still in the list?
      tempUnfilteredIssues.forEach((issue) => {
        if(issue.id === activeIssue.id) {
          holdoverActiveIssue = issue
        }
      })

      // If not, we need to do a more thorough check.
      if(holdoverActiveIssue === null) {
        tempUnfilteredIssues.forEach((issue) => {
          if(issue.contentId === activeIssue.contentId) {
            holdoverActiveIssue = issue
          }
        })
      }

      if(holdoverActiveIssue === null) {
        setWidgetState(WIDGET_STATE.LIST)
      }
    }

    setUnfilteredFiles(tempUnfilteredIssues)
    let tempFilteredContent = getFilteredContent(tempUnfilteredIssues, holdoverActiveIssue?.id || null)

    setFilteredFiles(tempFilteredContent)
    setActiveIssue(holdoverActiveIssue)
  }, [report])


  // When a new activeIssue is set, get the content for that issue
  useEffect(() => {
    if(activeIssue === null) {
      setTempActiveIssue(null)
      setWidgetState(WIDGET_STATE.LIST)
      return
    }
  
    setWidgetState(WIDGET_STATE.FIXIT)
    const activeIssueClone = JSON.parse(JSON.stringify(activeIssue))

    setTempActiveIssue(activeIssueClone)

  }, [activeIssue])

  const isDialogOpen = () => {
    const dialog = document.getElementById(dialogId)
    return dialog && dialog.open
  }


  const openDialog = () => {
    setWidgetState(WIDGET_STATE.FIXIT)

    const dialog = document.getElementById(dialogId)
    if(dialog) {
      dialog.showModal()
    }
  }

  const closeDialog = () => {
    setWidgetState(WIDGET_STATE.LIST)
    setActiveIssue(null)

    const dialog = document.getElementById(dialogId)
    if(dialog) {
      dialog.close()
    }
  }

  // useEffect(() => {
  //   const dialog = document.getElementById(dialogId)
  //   if(!dialog) {
  //     return
  //   }
  //   if(tempActiveIssue) {
  //     dialog.showModal()
  //   } else {
  //     dialog.close()
  //   }
  // }, [tempActiveIssue])

  const getFileTypeDisplay = (fileType) => {
    const fileTypeText = t(`label.mime.${fileType}`)

    return (
      <div className="table-pill" title={fileTypeText} aria-label={fileTypeText} >
        {fileType}
      </div>
    )
  }

  const getFileNameDisplay = (tempFile) => {
    const fileName = tempFile.contentTitle
    const fileType = tempFile.fileData.fileType

    return (
      <div className="flex-row gap-2">
        <div className="fileTypeIconBackground">
          <FileTypeIcon type={fileType} />
        </div>
        <div className="fileName" title={fileName} alt={fileName}>
          {fileName}
        </div>
      </div>
    )
  }

  const getFileStatusDisplay = (status) => {
    return (
      <div className={'table-status-container ' + status.toLowerCase()}>
        {status === FILTER.UNREVIEWED ? (
          <SeverityPotentialIcon className="icon-sm align-self-center" />
        ) : (
          <FixedIcon className="icon-sm align-self-center" />
        )}
        <div className='pl-2'>{t('fix.label.status.' + (status.toLowerCase()))}</div>
      </div>
    )
    
  }

  const getFilteredContent = (allIssues, includedIssueId = null) => {
    let filteredList = []
    const tempFilters = Object.assign({}, activeFilters)

    // PHPAlly Issues have a 'type' of 'error' or 'suggestion'
    // // Check for easy issues filter
    // if (tempFilters.easyIssues && tempFilters.issueTitles.length == 0) {
    //   tempFilters.issueTitles = easyRules
    // }
    // Loop through the issues

    for (const issue of allIssues) {

      // When we have just saved or resolved an issue, we want to keep that one in the list
      // even if it doesn't match the filters. This is used to show the user that their changes
      // were successful.
      if(includedIssueId && issue.id === includedIssueId) {
        filteredList.push(issue)
        continue
      }

      if(tempFilters[FILTER.TYPE.UTILIZATION] !== FILTER.ALL) {
        if(tempFilters[FILTER.TYPE.UTILIZATION] === FILTER.USED && issue?.fileData?.references?.length === 0) {
          continue
        }
        if(tempFilters[FILTER.TYPE.UTILIZATION] === FILTER.UNUSED && issue?.fileData?.references?.length > 0) {
          continue
        }
      }
      
      if (tempFilters[FILTER.TYPE.RESOLUTION] !== FILTER.ALL && tempFilters[FILTER.TYPE.RESOLUTION] !== issue.status) {
        continue
      }

      // Do not include this issue if it doesn't match the module filter
      if (tempFilters[FILTER.TYPE.MODULE] !== FILTER.ALL) {
        let sectionId = tempFilters[FILTER.TYPE.MODULE].toString().replace('section-', '')
        if (!issue.sectionIds.includes(sectionId)) {
          continue
        }
      }

      if (tempFilters[FILTER.TYPE.FILE_TYPE] !== FILTER.ALL && issue.fileType !== tempFilters[FILTER.TYPE.FILE_TYPE]) {
        continue
      }

      // Do not include this issue if it doesn't contain the search term/s
      if (searchTerm !== '') {
        const searchTerms = searchTerm.toLowerCase().split(' ')
        let containsAllTerms = true
        if (Array.isArray(searchTerms)) {
          for (let term of searchTerms) {
            if (!issue.keywords.includes(term)) {
              containsAllTerms = false
            }
          }
        }
        if (!containsAllTerms) {
          continue
        }
      }

      // If the issue passes all filters, add it to the list!
      filteredList.push(issue)
    }

    filteredList.sort((a, b) => {
      return (a.formLabel.toLowerCase() < b.formLabel.toLowerCase()) ? -1 : 1
    })

    return filteredList
  }

  // All local information must be updated to match the new issue state:
  // - activeIssue
  // - unfilteredIssues
  // - filteredIssues
  // This does NOT change the report object, which updates when the issue's data changes.
  const updateActiveSessionIssue = (issueId, state = null, contentItemId = null) => {
    
    if(state === null) {
      state = settings.ISSUE_STATE.UNCHANGED
    }

    // This updates the counter for the daily progress
    updateSessionIssue(issueId, state, contentItemId)

    // Only update the whole list if the issue is saved, resolved, or marked as unresolved.
    if(state === settings.ISSUE_STATE.SAVED
      || state === settings.ISSUE_STATE.RESOLVED
      || state === settings.ISSUE_STATE.UNCHANGED) {

        let tempUnfilteredIssues = unfilteredFiles.map((issue) => {
          if(issue.id === issueId) {
            let tempIssue = Object.assign({}, issue)
            tempIssue.currentState = state
            return tempIssue
          }
          return issue
        })
        setUnfilteredFiles(tempUnfilteredIssues)
        setFilteredFiles(getFilteredContent(tempUnfilteredIssues, activeIssue?.id || null))
    }

    // This updates the active issue to the current state, which allows the proper UI to show
    // (like "Processing..." which disables the buttons).
    if(activeIssue) {
      let tempIssue = activeIssue
      if(tempIssue.id === issueId) {
        tempIssue.currentState = state
        setActiveIssue(tempIssue)
      }
    }
  }

  const updateFile = (tempFile) => {
    const tempReport = Object.assign({}, report)

    // Occasionally, the report will send back a list of files in an object instead of an array.
    // It needs to be in array form for the Report.js file to process it correctly.
    if(!Array.isArray(tempReport.files)) {
      tempReport.files = Object.values(tempReport.files)
    }
 
    tempReport.files.forEach((reportFile, index) => {
      if (reportFile.id.toString() === tempFile.id.toString()) {
        if(activeIssue?.fileData?.id === tempFile.id && isDialogOpen()) {
          const formattedFile = formatFileData(tempFile)
          setActiveIssue(formattedFile)
        }
        tempReport.files[index] = JSON.parse(JSON.stringify(tempFile))
      }
    })
    processNewReport(tempReport)
  }

  /**
   * handleFileUpload is called when a new file has already been selected by the user
   * and is ready to be uploaded to the server and verified.
   */
  const handleFileUpload = (newFileData, changeReferences = false) => {

    const tempFile = Object.assign({}, activeIssue.fileData, { changeReferences: changeReferences } )

    updateActiveSessionIssue("file-" + tempFile.id, settings.ISSUE_STATE.SAVING)

    try {
      let api = new Api(settings)
      api.postFile(tempFile, newFileData)
        .then((responsStr) => responsStr.json())
        .then((response) => {
          if(response.errors && response.errors.length > 0) {
            response.errors.forEach((err) => addMessage({ message: t(err), severity: 'error', visible: true }))
            updateActiveSessionIssue("file-" + tempFile.id, settings.ISSUE_STATE.ERROR)
            return
          }

          const updatedFileData = response?.data?.lmsResponse?.content
          let metadataObj = tempFile?.metadata || {}
          console.log(updatedFileData)
          metadataObj.replacedByFileId = updatedFileData.id
          
          // Set messages 
          response.messages.forEach((msg) => addMessage(msg))

          // Update the local report and activeIssue
          updateActiveSessionIssue("file-" + tempFile.id, settings.ISSUE_STATE.SAVED)
          updateFile(updatedFileData)
        })
    } catch (error) {
      console.error(error)
      updateActiveSessionIssue("file-" + tempFile.id, settings.ISSUE_STATE.ERROR)
    }
  }

  const handleFileResolve = (fileData) => {
    updateActiveSessionIssue("file-" + fileData.id, settings.ISSUE_STATE.RESOLVING)
    
    let tempFile = Object.assign({}, fileData)
    tempFile.reviewed = !(tempFile.reviewed) 

    try {
      let api = new Api(settings)
      api.reviewFile(tempFile)
        .then((responseStr) => responseStr.json())
        .then((response) => {
          const reviewed = (response?.data?.file && ('reviewed' in response.data.file)) ? response.data.file.reviewed : false
          const newFileData = { ...tempFile }
          newFileData.reviewed = reviewed

          // Set messages
          response.messages.forEach((msg) => addMessage(msg))

          // Update the local report and activeIssue
          if(reviewed) {
            updateActiveSessionIssue("file-" + fileData.id, settings.ISSUE_STATE.RESOLVED)
          }
          else {
            updateActiveSessionIssue("file-" + fileData.id, settings.ISSUE_STATE.UNCHANGED)
          }
          updateFile(newFileData)
        })
    } catch (error) {
      console.warn(error)
      updateActiveSessionIssue("file-" + fileData.id, settings.ISSUE_STATE.ERROR)
    }
  }

  const updateActiveFilters = (filter, value) => {
    setActiveFilters(Object.assign({}, activeFilters, {[filter]: value}))
  }

  const jumpToFile = (fileId) => {
    let filteredFileIndex = filteredFiles.findIndex((issue) => issue.id === fileId)
    if(filteredFileIndex === -1) {
      return
    }

    setActiveIssue(filteredFiles[filteredFileIndex])
    openDialog()
  }

  const nextFile = (previous = false) => {
    if (!activeIssue || filteredFiles.length < 2) { return }
    let activeIndex = filteredFiles.findIndex((issue) => issue.id === activeIssue.id)

    if(activeIndex === -1) { return }

    // If we've reached the first or last issue, loop around
    let newIndex = activeIndex + (previous ? -1 : 1)
    if (newIndex < 0) {
      newIndex = filteredFiles.length - 1
    }
    else if (newIndex >= filteredFiles.length) {
      newIndex = 0
    }
    setActiveIssue(filteredFiles[newIndex])
  }

  return (
    <>
      { widgetState === WIDGET_STATE.LOADING ? (
        <></>
      ) : (
        <>
          <h1>Review Files</h1>
          <div className="subheader">Check files for common accessibility issues and update them if necessary.</div>

          <ReviewFilesFilters
            t={t}
            settings={settings}

            activeFilters={activeFilters}
            handleSearchTerm={setSearchTerm}
            searchTerm={searchTerm}
            sections={sections}
            updateActiveFilters={updateActiveFilters}
          />
          <div className="mt-1 subtext align-self-end">{t('fix.label.files_shown_count', { shown: filteredFiles?.length || 0, total: unfilteredFiles?.length || 0 })}</div>
          <div className="mt-1">
            {(rows.length > 0) ? <SortableTable
              t={t}
              headers={headers}
              rows={rows}
              tableSettings={tableSettings}
              handleTableSettings={handleTableSettings}
            /> : (
              <div className="flex-column gap-3 mt-3">
                <div className="flex-row align-self-center ms-3 me-3">
                  <h2 className="mt-0 mb-0 primary-dark">{t('report.label.no_results')}</h2>
                </div>
                <div className="flex-row align-self-center ms-3 me-3">
                  {t('report.msg.no_results')}
                </div>
              </div>
            )}
          </div>
        </>
      )}
      <dialog id={dialogId} className="dialog-full-screen" onClose={closeDialog}>
        <div className="flex-row gap-2 w-100 h-100">
          <section className='ufixit-widget-container'>
            <button onClick={closeDialog} className="btn btn-link btn-icon-left btn-small mb-2">
              <LeftArrowIcon className="icon-sm link-color" />{t('fix.button.files')}
            </button>
            { tempActiveIssue ? (  
                <FileFixitWidget
                  t={t}
                  settings={settings}
                  
                  handleFileResolve={handleFileResolve}
                  handleFileUpload={handleFileUpload}
                  sessionIssues={sessionIssues}
                  tempActiveIssue={tempActiveIssue}
                />
            ) : ''}
          </section>
          <section className="ufixit-content-container">
            {filteredFiles.length > 0 && tempActiveIssue && (
              <FileReviewPreview
                t={t}
                settings={settings}

                activeIssue={tempActiveIssue}
              />
            )}
            <div className="flex-row justify-content-end gap-2 mt-3">
              <button
                className={`btn btn-small btn-link btn-icon-left ${filteredFiles.length < 2 ? 'disabled' : ''}`}
                onClick={() => nextFile(true)}
                tabIndex="0">
                <LeftArrowIcon className={`icon-sm ` + (filteredFiles.length < 2 ? 'gray' : 'link-color')} />
                <div className="flex-column justify-content-center">{t('fix.button.previous_file')}</div>
              </button>

              <button
                className={`btn btn-small btn-link btn-icon-right ${filteredFiles.length < 2 ? 'disabled' : ''}`}
                onClick={() => nextFile()}
                tabIndex="0">
                <div className="flex-column justify-content-center">{t('fix.button.next_file')}</div>
                <RightArrowIcon className={`icon-sm ` + (filteredFiles.length < 2 ? 'gray' : 'link-color')} />
              </button>
            </div>
          </section>
        </div>
      </dialog>
    </>
  )
}