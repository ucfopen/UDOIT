import React, { useState, useEffect } from 'react'
import ReviewFilesFilters from './Widgets/ReviewFilesFilters'
import SortableTable from './Widgets/SortableTable'
import FileFixitWidget from './Widgets/FileFixitWidget'
import FileReviewPreview from './Widgets/FileReviewPreview'
import FileTypeIcon from './Icons/FileTypeIcon'
import LeftArrowIcon from './Icons/LeftArrowIcon'
import RightArrowIcon from './Icons/RightArrowIcon'
import SeverityPotentialIcon from './Icons/SeverityPotentialIcon'
import FixedIcon from './Icons/FixedIcon'
import * as Text from '../Services/Text'
import Api from '../Services/Api'

import './FixIssuesPage.css'
import './ReviewFilesPage.css'


/** The data for this component can be a bit confusing, so here's a breakdown:
  * - report: The main report object is generated by the scanner.
  * --- report.issues: All of the issues in a format that mirrors the database. Saving a loading is done with this.
  * --- report.files: All of the files in a format that mirrors the database. Saving a loading is done with this.
  * --- report.contentItems: All of the content items in the course. This is used to store the content for each issue.
  * 
  * After the data is brought in through the API, it is formatted in the formatIssueData and formatFileData functions
  * and stored in a list that can be filtered.
  * - unfilteredIssues: A list of all the issues in the course, formatted for the front end.
  * - filteredIssues: A list of the issues that match the current filters and search term.
  * - activeIssue: The issue that is currently being viewed and edited, including non-database attributes
  * --- activeIssue.issueData: The issue as it is stored in the database. Matches report.issues for the issue.
  * --- activeIssue.fileData: The file as it is stored in the database. Matches report.files for the file.
**/
import * as Html from '../Services/Html.js'

export default function ReviewFilesPage({
  t,
  settings,
  
  report,
  sections,
  processNewReport,
  addMessage,
  sessionFiles,
  updateSessionFiles
})
{

  // Define the kinds of filters that will be available to the user
  const FILTER = settings.FILE_FILTER

  const defaultFilters = {
    [FILTER.TYPE.UTILIZATION]: FILTER.USED,
    [FILTER.TYPE.FILE_TYPE]: FILTER.ALL,
    [FILTER.TYPE.RESOLUTION]: FILTER.UNREVIEWED,
    [FILTER.TYPE.MODULE]: FILTER.ALL,
  }

  const WIDGET_STATE = settings.WIDGET_STATE

  const dialogId = "file-dialog"

  const headers = [
    { id: "name", text: t('fix.label.file_name') },
    { id: "type", text: t('fix.label.file_type')},
    { id: "references", text: t('fix.label.references')},
    { id: "date", text: t('fix.label.file_updated')},
    { id: "size", text: t('fix.label.file_size')},
    { id: "status", text: t('fix.label.status')},
  ]

  const [tableSettings, setTableSettings] = useState({
      sortBy: 'name',
      ascending: false,
      pageNum: 0,
  })

  const handleTableSettings = (setting) => {
    setTableSettings(Object.assign({}, tableSettings, setting))
  }

  const [rows, setRows] = useState([])
  const [activeIssue, setActiveIssue] = useState(null)
  const [tempActiveIssue, setTempActiveIssue] = useState(null)
  const [searchTerm, setSearchTerm] = useState('')
  const [activeFilters, setActiveFilters] = useState(defaultFilters)
  const [unfilteredFiles, setUnfilteredFiles] = useState([])
  const [filteredFiles, setFilteredFiles] = useState([])
  const [widgetState, setWidgetState] = useState(WIDGET_STATE.LOADING)

  const formatFileData = (fileData) => {

    let fileId = fileData.id

    let issueResolution = (fileData.reviewed ? FILTER.REVIEWED : FILTER.UNREVIEWED)

    let formLabel = t(`form.file.title`)

    let fileType = FILTER.FILE_UNKNOWN
    let fileTypeLabel = t(`label.mime.unknown`)
    
    // Guarantee that the keywords include the word "file" in each language
    let keywords = [ fileData.fileName ? fileData.fileName.toLowerCase() : fileData.display_name.toLowerCase() ]
    
    // Keywords should include the file type ('MS Word', 'PDF', etc.)
    if(settings.FILE_TYPES.includes(fileData.fileType)) {
      fileType = settings.FILE_TYPE_MAP[fileData.fileType]
      fileTypeLabel = t(`label.mime.${fileData.fileType}`)
      keywords.push[fileTypeLabel.toLowerCase()]
    }

    keywords = keywords.join(' ')

    let currentState = settings.ISSUE_STATE.UNCHANGED
    if(sessionFiles && sessionFiles[fileId]) {
      currentState = sessionFiles[fileId]
    }

    return {
      fileData: Object.assign({}, fileData),
      id: fileId,
      severity: FILTER.POTENTIAL,
      status: issueResolution,
      published: true,
      fileType: fileType,
      sectionIds: fileData?.sectionRefs?.map((section) => section.moduleId.toString()) || [],
      keywords: keywords,
      scanRuleId: 'verify_file_accessibility',
      formLabel: formLabel,
      contentId: fileData.lmsFileId,
      contentType: FILTER.FILE_OBJECT,
      contentTitle: fileData.fileName,
      contentUrl: fileData.lmsUrl,
      currentState: currentState,
    }
  }

  // When the filters or search term changes, update the filtered issues list
  useEffect(() => {

    let tempFilteredFiles = getFilteredContent(unfilteredFiles)
    let tempTableSettings = Object.assign({}, tableSettings)

    if(tempFilteredFiles.length !== filteredFiles.length) {
      tempTableSettings.pageNum = 0
      handleTableSettings({ pageNum: 0 })
    }

    setFilteredFiles(tempFilteredFiles)
    setWidgetState(WIDGET_STATE.LIST)

  }, [activeFilters, searchTerm])

  const getContent = () => {
    if (filteredFiles.length === 0) {
      return []
    }

    let tempRows = []
    filteredFiles.forEach((tempFile) => {
      tempRows.push({
        id: tempFile.id,
        name: tempFile.contentTitle ? { value: tempFile.contentTitle, display: getFileNameDisplay(tempFile)} : t('label.unknown'),
        type: tempFile.fileData.fileType ? { value: tempFile.fileData.fileType, display: getFileTypeDisplay(tempFile.fileData.fileType)}: t('label.mime.unknown'),
        date: tempFile.fileData.updated ? { value: tempFile.fileData.updated, display: Text.getReadableDateTime(tempFile.fileData.updated)} : t('label.unknown'),
        size: tempFile.fileData.fileSize ? { value: parseInt(tempFile.fileData.fileSize), display: Text.getReadableFileSize(tempFile.fileData.fileSize) } : t('label.unknown'),
        references: (tempFile.fileData?.references.length) || 0,
        status: tempFile.status ? { value: t('fix.label.status.' + (tempFile.status.toLowerCase())), display: getFileStatusDisplay(tempFile.status)} : '',
        onClick: () => { jumpToFile(tempFile.id) },
        onKeyDown: (e) => {
          if (e.key === 'Enter' || e.key === ' ') {
            jumpToFile(tempFile.id)
          }
        },
        label: tempFile.contentTitle + ' - ' + t('fix.label.status.' + (tempFile.status.toLowerCase()))
      })
    })

    const { sortBy, ascending } = tableSettings

    tempRows.sort((a, b) => {
      let aSort = a[sortBy]
      if(typeof aSort === 'object' && aSort.value) {
        aSort = aSort.value
      }
      
      let bSort = b[sortBy]
      if(typeof bSort === 'object' && bSort.value) {
        bSort = bSort.value
      }

      if (isNaN(aSort) || isNaN(bSort)) {
        return (aSort.toLowerCase() > bSort.toLowerCase()) ? -1 : 1
      }
      else {
        return (Number(aSort) < Number(bSort)) ? -1 : 1
      }
    })

    if (!ascending) {
      tempRows.reverse()
    }

    return tempRows
  }

  useEffect(() => {
    setRows(getContent())
  }, [tableSettings, filteredFiles])

  // The report object is updated whenever a scan or rescan is completed. At this point, the list of issues
  // needs to be rebuilt and the activeIssue may need to be updated. For instance, if an issue is marked as
  // unreviewed then it will be deleted during the rescan and a new issue with a new id will take its place.
  useEffect(() => {
    let tempUnfilteredIssues = []

    let tempFiles = Object.assign({}, report.files)
    for (const [key, value] of Object.entries(tempFiles)) {
      let tempFile = formatFileData(value)
      tempUnfilteredIssues.push(tempFile)
    }

    tempUnfilteredIssues.sort((a, b) => {
      return (a.formLabel.toLowerCase() < b.formLabel.toLowerCase()) ? -1 : 1
    })

    // The filtered list should ALWAYS include the current activeIssue, even if it no longer matches
    // the filters. For instance, if I'm only looking through "Unreviewed" issues, and I click on the
    // "Mark as Reviewed" button, that newly-reviewed issue should be available to stay on screen.
    let holdoverActiveIssue = null

    // If there is an activeIssue, we need to connect it to something in the new list of issues.
    if(activeIssue) {  
      // Quick check: is the old activeIssue still in the list?
      tempUnfilteredIssues.forEach((issue) => {
        if(issue.id === activeIssue.id) {
          holdoverActiveIssue = issue
        }
      })

      // If not, we need to do a more thorough check.
      if(holdoverActiveIssue === null) {
        tempUnfilteredIssues.forEach((issue) => {
          if(issue.contentId === activeIssue.contentId) {
            holdoverActiveIssue = issue
          }
        })
      }

      if(holdoverActiveIssue === null) {
        setWidgetState(WIDGET_STATE.LIST)
      }
    }

    setUnfilteredFiles(tempUnfilteredIssues)
    let tempFilteredContent = getFilteredContent(tempUnfilteredIssues, holdoverActiveIssue?.id || null)

    setFilteredFiles(tempFilteredContent)
    setActiveIssue(holdoverActiveIssue)
  }, [report])


  // When a new activeIssue is set, get the content for that issue
  useEffect(() => {
    if(activeIssue === null) {
      setTempActiveIssue(null)
      setWidgetState(WIDGET_STATE.LIST)
      return
    }
  
    setWidgetState(WIDGET_STATE.FIXIT)
    const activeIssueClone = JSON.parse(JSON.stringify(activeIssue))

    setTempActiveIssue(activeIssueClone)
  }, [activeIssue])

  const isDialogOpen = () => {
    const dialog = document.getElementById(dialogId)
    return dialog && dialog.open
  }


  const openDialog = () => {
    setWidgetState(WIDGET_STATE.FIXIT)

    const dialog = document.getElementById(dialogId)
    if(dialog) {
      dialog.showModal()
    }
  }

  const closeDialog = () => {
    setWidgetState(WIDGET_STATE.LIST)
    setActiveIssue(null)

    const dialog = document.getElementById(dialogId)
    if(dialog) {
      dialog.close()
    }
  }

  const getFileTypeDisplay = (fileType) => {
    const fileTypeText = t(`label.mime.${fileType}`)

    return (
      <div className="table-pill" title={fileTypeText}>
        {fileType}
      </div>
    )
  }

  const getFileNameDisplay = (tempFile) => {
    const fileName = tempFile.contentTitle
    const fileType = tempFile.fileData.fileType

    return (
      <div className="flex-row gap-2" aria-label={fileName}>
        <div className="fileTypeIconBackground" aria-hidden="true">
          <FileTypeIcon type={fileType} />
        </div>
        <div className="fileName" title={fileName} aria-hidden="true">
          {fileName}
        </div>
      </div>
    )
  }

  const getFileStatusDisplay = (status) => {
    return (
      <div className={'table-status-container ' + status.toLowerCase()} aria-label={t('fix.label.status.' + (status.toLowerCase()))}>
        {status === FILTER.UNREVIEWED ? (
          <SeverityPotentialIcon className="icon-sm align-self-center" aria-hidden="true"/>
        ) : (
          <FixedIcon className="icon-sm align-self-center" aria-hidden="true" />
        )}
        <div className='pl-2' aria-hidden="true">{t('fix.label.status.' + (status.toLowerCase()))}</div>
      </div>
    )
    
  }

  const getFilteredContent = (allIssues, includedIssueId = null) => {
    let filteredList = []
    const tempFilters = Object.assign({}, activeFilters)

    // PHPAlly Issues have a 'type' of 'error' or 'suggestion'
    // // Check for easy issues filter
    // if (tempFilters.easyIssues && tempFilters.issueTitles.length == 0) {
    //   tempFilters.issueTitles = easyRules
    // }
    // Loop through the issues

    for (const issue of allIssues) {

      // When we have just saved or resolved an issue, we want to keep that one in the list
      // even if it doesn't match the filters. This is used to show the user that their changes
      // were successful.
      if(includedIssueId && issue.id === includedIssueId) {
        filteredList.push(issue)
        continue
      }

      if(tempFilters[FILTER.TYPE.UTILIZATION] !== FILTER.ALL) {
        if(tempFilters[FILTER.TYPE.UTILIZATION] === FILTER.USED && issue?.fileData?.references?.length === 0 && issue?.fileData?.sectionRefs?.length == 0) {
          continue
        }
        if(tempFilters[FILTER.TYPE.UTILIZATION] === FILTER.UNUSED && (issue?.fileData?.references?.length > 0 || issue?.fileData?.sectionRefs?.length > 0)) {
          continue
        }
      }
      
      if (tempFilters[FILTER.TYPE.RESOLUTION] !== FILTER.ALL && tempFilters[FILTER.TYPE.RESOLUTION] !== issue.status) {
        continue
      }

      // Do not include this issue if it doesn't match the module filter
      if (tempFilters[FILTER.TYPE.MODULE] !== FILTER.ALL) {
        let sectionId = tempFilters[FILTER.TYPE.MODULE].toString().replace('section-', '')
        if (!issue.sectionIds.includes(sectionId)) {
          continue
        }
      }

      if (tempFilters[FILTER.TYPE.FILE_TYPE] !== FILTER.ALL && issue.fileType !== tempFilters[FILTER.TYPE.FILE_TYPE]) {
        continue
      }

      // Do not include this issue if it doesn't contain the search term/s
      if (searchTerm !== '') {
        const searchTerms = searchTerm.toLowerCase().split(' ')
        let containsAllTerms = true
        if (Array.isArray(searchTerms)) {
          for (let term of searchTerms) {
            if (!issue.keywords.includes(term)) {
              containsAllTerms = false
            }
          }
        }
        if (!containsAllTerms) {
          continue
        }
      }

      // If the issue passes all filters, add it to the list!
      filteredList.push(issue)
    }

    filteredList.sort((a, b) => {
      return (a.formLabel.toLowerCase() < b.formLabel.toLowerCase()) ? -1 : 1
    })

    return filteredList
  }

  // All local information must be updated to match the new issue state:
  // - activeIssue
  // - unfilteredIssues
  // - filteredIssues
  // This does NOT change the report object, which updates when the issue's data changes.
  const updateActiveSessionFile = (fileId, state = null, contentItemId = null) => {
    if(state === null) {
      state = settings.ISSUE_STATE.UNCHANGED
    }

    // This updates the counter for the daily progress
    updateSessionFiles(fileId, state, contentItemId)

    // Only update the whole list if the issue is saved, resolved, or marked as unresolved.
    if(state === settings.ISSUE_STATE.SAVED
      || state === settings.ISSUE_STATE.RESOLVED
      || state === settings.ISSUE_STATE.UNCHANGED) {

        let tempUnfilteredIssues = unfilteredFiles.map((issue) => {
          if(issue.id === fileId) {
            let tempIssue = Object.assign({}, issue)
            tempIssue.currentState = state
            return tempIssue
          }
          return issue
        })
        setUnfilteredFiles(tempUnfilteredIssues)
        setFilteredFiles(getFilteredContent(tempUnfilteredIssues, activeIssue?.id || null))
    }

    // This updates the active issue to the current state, which allows the proper UI to show
    // (like "Processing..." which disables the buttons).
    if(activeIssue) {
      let tempIssue = JSON.parse(JSON.stringify(activeIssue))
      if(tempIssue.id === fileId) {
        tempIssue.currentState = state

      }
    }
  }

  const extractUrl = (url) => {
  if(!url) return ''
  
  const idx = url.indexOf('courses/');
  if (idx !== -1) {
    // slice from "courses/" onward and strip any leading slashes (defensive)
    return url.slice(idx).replace(/^\/+/, '');
  }

  // if no "courses/" found, remove leading slashes and return the remainder
  return url.replace(/^\/+/, '');
}

  const updateFile = (tempFile, copiedReport, newFile = null, ) => {
    const tempReport = Object.assign({}, copiedReport)
    if(!Array.isArray(tempReport.files)){
      tempReport.files = Object.values(tempReport.files)
    }
    if(newFile){
      tempReport.push(newFile)
    }
    for(let i = 0; i < tempReport.files.length; i++){
      if(tempReport.files[i].lmsFileId.toString() == tempFile.lmsFileId.toString()){
        tempReport.files[i] = tempFile
      }
    }
    
    return tempReport
  }

  // Given a html returns updated html with all file links replaced
  const replaceFileInHtml = (contentItemBody, fileId, newUrl) => {
    const parser = new DOMParser()
    const tempBody = parser.parseFromString(contentItemBody, 'text/html')
    let links = tempBody.getElementsByTagName('a')
    const fileUrlPattern = /\/files\/(\d+)/
    for(let i = 0; i < links.length; i++) {
      let link = links[i]
      let href = link.getAttribute('href')
      if(href){
        let match = href.match(fileUrlPattern)
        if(match && match[1] && match[1] == fileId){
            link.setAttribute('href', newUrl) 
        }
      }
    }
    return Html.toString(tempBody.body)
  }

  const handleFileDelete = async () => {
    try{
      let api = new Api(settings)
      const responseStr = await api.deleteFile(activeIssue.fileData)
      const response = await responseStr.json()
      if(response?.errors && response.errors.length > 0){
         response.errors.forEach((err) => addMessage(err))
         return
      }

      const tempReport = JSON.parse(JSON.stringify(report))
      if(!Array.isArray(tempReport.files)){
        tempReport.files = Object.values(tempReport.files)
      }

      // Move over to the next file as we are deleting the current one
      let nextFileIndex = tempReport.files.findIndex((file) => file.id == activeIssue.fileData.id) + 1
      nextFileIndex = nextFileIndex >= report.files.length ? 0 : nextFileIndex
      const tempNext = tempReport.files[nextFileIndex]
       
      // Remove the current file from the list and adjust active issue
      tempReport.files = tempReport.files.filter((file) => file.id != activeIssue.fileData.id)
      if(tempNext){
        const tempFileIssue = formatFileData(tempNext)
        setActiveIssue(tempFileIssue)
      }

      // Add success messages 
      response.messages.forEach((msg) => addMessage(msg))
      processNewReport(tempReport)
    }
    catch(error){
      addMessage(error)
      console.error(error)
      return
    }
  }

  const createContentItemPostOptions = (fullPageHtml, contentUrl, contentId, contentType, sectionIds) => {
      const contentItemOption = {
        fullPageHtml: fullPageHtml,
        contentUrl: contentUrl,
        contentId: contentId,
        contentType: contentType,
        sectionIds: sectionIds?.length > 0 ? sectionIds : []
      }

      return contentItemOption
  }

  const createSectionPostOptions = (newFile, moduleId, position, itemId, indent) => {
    const sectionIdOption = {
      fileName: newFile.fileName,
      fileId: newFile.lmsFileId,
      moduleId: moduleId,
      position: position,
      itemid: itemId,
      indent: indent,
      courseId: settings.course.lmsCourseId
    }
    return sectionIdOption
  }

  const getContentPostItems = (file, newFile, contentReferences) => {
    const postContentItemOptions = []
    if(contentReferences?.length > 0){
      contentReferences.map((reference) => {
        let newFullPageHtml = ""
        if(reference.contentItemBody){
          newFullPageHtml = replaceFileInHtml(reference.contentItemBody, file.lmsFileId, newFile.metadata.url)
        }
        postContentItemOptions.push(createContentItemPostOptions(newFullPageHtml, extractUrl(reference.contentItemUrl), reference.contentItemId, reference.contentType, reference.sectionIds))
      })
    }
    return postContentItemOptions
  }

const getSectionPostOptions = (newFile, sectionReferences) => {
    const postSectionOptions = []
    if(sectionReferences?.length > 0){
      sectionReferences.map((sectionRef) => {
         postSectionOptions.push(createSectionPostOptions(newFile, sectionRef.moduleId, sectionRef.itemPosition, sectionRef.itemId, sectionRef.indent))
      })
    }
    return postSectionOptions
  }

  const updateAndScanContent = async (postContentItemOptions, postSectionItemOption) => {
    const responseStatus = []
    try{
      let api = new Api(settings)
      const responseStr = await api.updateContent(postContentItemOptions, postSectionItemOption)
      const response = await responseStr.json()
      if (response.errors && response.errors.length > 0) {
      response.errors.forEach((error) => {
        responseStatus.push({ status: "error", message: error })
      })
      return responseStatus;
    }
      const newContent = response?.data?.content;
      let contentIndex = 1;
      for (const content of newContent) {
        const isLastContent = contentIndex == newContent.length;
        contentIndex++;
        if(content.status == 200){
          if(content.type != 'section'){
              const scanResponseStr = await api.scanContent(content.id, false);
              const scanResponse = await scanResponseStr.json();
              if (scanResponse?.messages[0]?.severity != "success") {
                responseStatus.push({ status: "error", message: "Failure to scan content" });
                return responseStatus;
              }
          }
        }
        if(isLastContent) {
            const reportResponseStr = await api.updateAndGetReport(settings.course.id)
            const reportResponse = await reportResponseStr.json()
            if(reportResponse){
              if(reportResponse.messages[0].severity == 'success'){
                const newReport = reportResponse.data
                responseStatus.push({ status: "success", message: newReport});
                return responseStatus;
              }
              else{
                responseStatus.push({ status: "error", message:"Failed to retrive new report" });
                return responseStatus;
              }
            }
          }
      }
    }
    catch(error){
      responseStatus.push({type: "error", message: error})
      return responseStatus
    }
  }

  const handleFileUpload  = async (newFileData, contentReferences, sectionReferences) => {
    const tempFile = Object.assign({}, activeIssue.fileData)
    updateActiveSessionFile(tempFile.id, settings.ISSUE_STATE.SAVING)
    try{
      // File Upload to Canvas
      let api = new Api(settings)
      const responseStr = await api.postFile(tempFile, newFileData)
      const response = await responseStr.json()
      if(response.errors && response.errors.length > 0) {
        response.errors.forEach((err) => addMessage({ message: t(err), severity: 'error', visible: true }))
        updateActiveSessionFile(tempFile.id, settings.ISSUE_STATE.ERROR)
        return
      }

      // Setting data for new file and adjusting old file
      const updatedFileData = response?.data?.newFile
      let metadataObj = tempFile?.metadata || {}
      metadataObj.replacementFileId = updatedFileData?.metadata.id
      tempFile.replacement = updatedFileData

      // Copying and pushing new file onto report
      let tempReport = JSON.parse(JSON.stringify(report))
      if(!Array.isArray(tempReport.files)){
        tempReport.files = Object.values(tempReport.files)
      }
      tempReport.files.push(updatedFileData)
      let canMarkReview = false // Use this to track if the file should be marked as 'reviewed'/'resolved' 

      // Build content and section items POST data
      const postContentItemOptions = getContentPostItems(tempFile, updatedFileData, contentReferences)
      const postSectionOptions = getSectionPostOptions(updatedFileData, sectionReferences)

      if((postContentItemOptions && postContentItemOptions.length > 0) ||  (postSectionOptions && postSectionOptions.length > 0)){
        const responseStatus = await updateAndScanContent(postContentItemOptions, postSectionOptions)
        if(responseStatus && responseStatus[0]?.type == "error"){
          responseStatus.forEach((err) => addMessage({message: err.message, severity: 'error', visible:true}))
          updateActiveSessionFile(tempFile.id, settings.ISSUE_STATE.ERROR)
          return
        }
        else if(responseStatus && responseStatus[0]?.status == "success"){
          tempReport = responseStatus[0].message
          tempReport = processNewReport(tempReport)
        }
      }

      if(!Array.isArray(tempReport.files)){
        tempReport.files = Object.values(tempReport.files)
      }
      const currentFile = tempReport.files.find((file) => file.id == activeIssue.id) 
      canMarkReview = currentFile ? (currentFile?.references?.length == 0 && currentFile?.sectionRefs?.length == 0) : false
      if(canMarkReview){
          const resolvedReport = await handleFileResolve(tempFile, true, tempReport, true, false)
          tempReport = resolvedReport ? resolvedReport : tempReport
          updateActiveSessionFile(tempFile.id, settings.ISSUE_STATE.SAVED)
      }
      else{
        updateActiveSessionFile(tempFile.id, settings.ISSUE_STATE.UNCHANGED)
      }
      // Our file upload process is done at this point so we can add the messages
      response.messages.forEach((msg) => addMessage(msg))     
      processNewReport(tempReport)
    }
    catch (error) {
      console.error(error)
      updateActiveSessionFile(tempFile.id, settings.ISSUE_STATE.ERROR)
    }
  }

  const handleFileResolve = async (fileData, getReport = false, copiedReport = report, forceReview = false, replace = false) => {
    updateActiveSessionFile(fileData.id, settings.ISSUE_STATE.RESOLVING)
    fileData.reviewed = !(fileData.reviewed) || forceReview
    if(replace){
        fileData.replacement = null
        fileData.metadata.replacementFileId = -1
      }
    try{
      let api = new Api(settings)
      const responseStr = await api.reviewFile(fileData, replace)
      const response = await responseStr.json()

      const reviewed = (response?.data?.file && ('reviewed' in response.data.file)) ? response.data.file.reviewed : false
      fileData.reviewed = reviewed

       // Set messages
      response.messages.forEach((msg) => addMessage(msg))

      // Update the local report and activeIssue
      if(reviewed) {
        updateActiveSessionFile(fileData.id, settings.ISSUE_STATE.RESOLVED)
      }
      else {
        updateActiveSessionFile(fileData.id, settings.ISSUE_STATE.UNCHANGED)
      }
      const newReport = updateFile(fileData, copiedReport)
      if(getReport){
        return newReport
      }
      processNewReport(newReport)
    }
    catch(error){
      console.warn(error)
      updateActiveSessionFile(fileData.id, settings.ISSUE_STATE.ERROR)
    }
  }

  const handleFileRevert = async (activeFile, contentReferences, sectionReferences) => {
    let tempReport = JSON.parse(JSON.stringify(report))
    if(!Array.isArray(tempReport.files)){
      tempReport.files = Object.values(tempReport.files)
    }
    const postContentItemOptions = getContentPostItems(activeFile.replacement, activeFile, contentReferences)
    const postSectionOptions = getSectionPostOptions(activeFile, sectionReferences)

    if((postContentItemOptions && postContentItemOptions.length > 0) ||  (postSectionOptions && postSectionOptions.length > 0)){
        const responseStatus = await updateAndScanContent(postContentItemOptions, postSectionOptions)
        if(responseStatus && responseStatus[0]?.type == "error"){
          responseStatus.forEach((err) => addMessage({message: err.message, severity: 'error', visible:true}))
          updateActiveSessionFile(tempFile.id, settings.ISSUE_STATE.ERROR)
          return
        }
        else if(responseStatus && responseStatus[0]?.status == "success"){
          tempReport = responseStatus[0].message
          tempReport = processNewReport(tempReport)
        }
      }
    
    if(!Array.isArray(tempReport.files)){
        tempReport.files = Object.values(tempReport.files)
    }
    let currentFile = tempReport.files.find((file) => file.id == activeIssue.id)
    const resolvedReport = await handleFileResolve(currentFile, true, tempReport, false, true)
    processNewReport(resolvedReport)

  }

  const updateActiveFilters = (filter, value) => {
    setActiveFilters(Object.assign({}, activeFilters, {[filter]: value}))
  }

  const jumpToFile = (fileId) => {
    let filteredFileIndex = filteredFiles.findIndex((issue) => issue.id === fileId)
    if(filteredFileIndex === -1) {
      return
    }

    setActiveIssue(filteredFiles[filteredFileIndex])
    openDialog()
  }

  const nextFile = (previous = false) => {
    if (!activeIssue || filteredFiles.length < 2) { return }
    let activeIndex = filteredFiles.findIndex((issue) => issue.id === activeIssue.id)

    if(activeIndex === -1) { return }

    // If we've reached the first or last issue, loop around
    let newIndex = activeIndex + (previous ? -1 : 1)
    if (newIndex < 0) {
      newIndex = filteredFiles.length - 1
    }
    else if (newIndex >= filteredFiles.length) {
      newIndex = 0
    }
    setActiveIssue(filteredFiles[newIndex])
  }

  return (
    <>
      { widgetState === WIDGET_STATE.LOADING ? (
        <></>
      ) : (
        <>
          <h1>Review Files</h1>
          <div className="subheader">Check files for common accessibility issues and update them if necessary.</div>

          <ReviewFilesFilters
            t={t}
            settings={settings}

            activeFilters={activeFilters}
            handleSearchTerm={setSearchTerm}
            searchTerm={searchTerm}
            sections={sections}
            updateActiveFilters={updateActiveFilters}
          />
          <div className="mt-1 subtext align-self-end">{t('fix.label.files_shown_count', { shown: filteredFiles?.length || 0, total: unfilteredFiles?.length || 0 })}</div>
          <div className="mt-1">
            {(rows.length > 0) ? <SortableTable
              t={t}
              headers={headers}
              rows={rows}
              tableSettings={tableSettings}
              handleTableSettings={handleTableSettings}
            /> : (
              <div className="flex-column gap-3 mt-3">
                <div className="flex-row align-self-center ms-3 me-3">
                  <h2 className="mt-0 mb-0 primary-dark">{t('report.label.no_results')}</h2>
                </div>
                <div className="flex-row align-self-center ms-3 me-3">
                  {t('report.msg.no_results')}
                </div>
              </div>
            )}
          </div>
        </>
      )}
      <dialog id={dialogId} className="dialog-full-screen" onClose={closeDialog}>
        <div className="flex-row gap-2 w-100 h-100">
          <section className='ufixit-widget-container'>
            <button onClick={closeDialog} className="btn btn-link btn-icon-left btn-small mb-2">
              <LeftArrowIcon className="icon-sm link-color" />{t('fix.button.files')}
            </button>
            { tempActiveIssue ? (  
                <FileFixitWidget
                  t={t}
                  settings={settings}
                  sessionFiles={sessionFiles}
                  handleFileUpload={handleFileUpload}
                  handleFileDelete={handleFileDelete}
                  handleFileResolve={handleFileResolve}
                  tempActiveIssue={tempActiveIssue}
                />
            ) : ''}
          </section>
          <section className="ufixit-content-container">
            {filteredFiles.length > 0 && tempActiveIssue && (
              <FileReviewPreview
                t={t}
                settings={settings}

                activeIssue={tempActiveIssue}
              />
            )}
            <div className="flex-row justify-content-end gap-2 mt-3">
              <button
                className={`btn btn-small btn-link btn-icon-left ${filteredFiles.length < 2 ? 'disabled' : ''}`}
                onClick={() => nextFile(true)}
                tabIndex="0">
                <LeftArrowIcon className={`icon-sm ` + (filteredFiles.length < 2 ? 'gray' : 'link-color')} />
                <div className="flex-column justify-content-center">{t('fix.button.previous_file')}</div>
              </button>

              <button
                className={`btn btn-small btn-link btn-icon-right ${filteredFiles.length < 2 ? 'disabled' : ''}`}
                onClick={() => nextFile()}
                tabIndex="0">
                <div className="flex-column justify-content-center">{t('fix.button.next_file')}</div>
                <RightArrowIcon className={`icon-sm ` + (filteredFiles.length < 2 ? 'gray' : 'link-color')} />
              </button>
            </div>
          </section>
        </div>
      </dialog>
    </>
  )
}